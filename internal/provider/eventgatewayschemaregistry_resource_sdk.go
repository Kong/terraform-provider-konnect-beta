// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-konnect-beta/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-konnect-beta/internal/provider/types"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/models/shared"
)

func (r *EventGatewaySchemaRegistryResourceModel) RefreshFromSharedSchemaRegistry(ctx context.Context, resp *shared.SchemaRegistry) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		if resp.Config == nil {
			r.Config = nil
		} else {
			r.Config = &tfTypes.BackendClusterAuthenticationAnonymous{}
		}
		r.CreatedAt = types.StringValue(typeconvert.TimeToString(resp.CreatedAt))
		r.Description = types.StringPointerValue(resp.Description)
		r.ID = types.StringValue(resp.ID)
		if len(resp.Labels) > 0 {
			r.Labels = make(map[string]types.String, len(resp.Labels))
			for key, value := range resp.Labels {
				r.Labels[key] = types.StringPointerValue(value)
			}
		}
		r.Name = types.StringValue(resp.Name)
		r.Type = types.StringValue(resp.Type)
		r.UpdatedAt = types.StringValue(typeconvert.TimeToString(resp.UpdatedAt))
	}

	return diags
}

func (r *EventGatewaySchemaRegistryResourceModel) ToOperationsCreateEventGatewaySchemaRegistryRequest(ctx context.Context) (*operations.CreateEventGatewaySchemaRegistryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	modifySchemaRegistry, modifySchemaRegistryDiags := r.ToSharedModifySchemaRegistry(ctx)
	diags.Append(modifySchemaRegistryDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.CreateEventGatewaySchemaRegistryRequest{
		GatewayID:            gatewayID,
		ModifySchemaRegistry: modifySchemaRegistry,
	}

	return &out, diags
}

func (r *EventGatewaySchemaRegistryResourceModel) ToOperationsDeleteEventGatewaySchemaRegistryRequest(ctx context.Context) (*operations.DeleteEventGatewaySchemaRegistryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	var schemaRegistryID string
	schemaRegistryID = r.ID.ValueString()

	out := operations.DeleteEventGatewaySchemaRegistryRequest{
		GatewayID:        gatewayID,
		SchemaRegistryID: schemaRegistryID,
	}

	return &out, diags
}

func (r *EventGatewaySchemaRegistryResourceModel) ToOperationsGetEventGatewaySchemaRegistryRequest(ctx context.Context) (*operations.GetEventGatewaySchemaRegistryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	var schemaRegistryID string
	schemaRegistryID = r.ID.ValueString()

	out := operations.GetEventGatewaySchemaRegistryRequest{
		GatewayID:        gatewayID,
		SchemaRegistryID: schemaRegistryID,
	}

	return &out, diags
}

func (r *EventGatewaySchemaRegistryResourceModel) ToOperationsUpdateEventGatewaySchemaRegistryRequest(ctx context.Context) (*operations.UpdateEventGatewaySchemaRegistryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var gatewayID string
	gatewayID = r.GatewayID.ValueString()

	var schemaRegistryID string
	schemaRegistryID = r.ID.ValueString()

	modifySchemaRegistry, modifySchemaRegistryDiags := r.ToSharedModifySchemaRegistry(ctx)
	diags.Append(modifySchemaRegistryDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.UpdateEventGatewaySchemaRegistryRequest{
		GatewayID:            gatewayID,
		SchemaRegistryID:     schemaRegistryID,
		ModifySchemaRegistry: modifySchemaRegistry,
	}

	return &out, diags
}

func (r *EventGatewaySchemaRegistryResourceModel) ToSharedModifySchemaRegistry(ctx context.Context) (*shared.ModifySchemaRegistry, diag.Diagnostics) {
	var diags diag.Diagnostics

	var out shared.ModifySchemaRegistry
	var schemaRegistryConfluent *shared.SchemaRegistryConfluent
	if r.Confluent != nil {
		var name string
		name = r.Confluent.Name.ValueString()

		description := new(string)
		if !r.Confluent.Description.IsUnknown() && !r.Confluent.Description.IsNull() {
			*description = r.Confluent.Description.ValueString()
		} else {
			description = nil
		}
		schemaType := shared.SchemaType(r.Confluent.Config.SchemaType.ValueString())
		var endpoint string
		endpoint = r.Confluent.Config.Endpoint.ValueString()

		timeoutSeconds := new(int64)
		if !r.Confluent.Config.TimeoutSeconds.IsUnknown() && !r.Confluent.Config.TimeoutSeconds.IsNull() {
			*timeoutSeconds = r.Confluent.Config.TimeoutSeconds.ValueInt64()
		} else {
			timeoutSeconds = nil
		}
		var authentication *shared.SchemaRegistryAuthenticationScheme
		if r.Confluent.Config.Authentication != nil {
			var schemaRegistryAuthenticationBasic *shared.SchemaRegistryAuthenticationBasic
			if r.Confluent.Config.Authentication.Basic != nil {
				var username string
				username = r.Confluent.Config.Authentication.Basic.Username.ValueString()

				var password string
				password = r.Confluent.Config.Authentication.Basic.Password.ValueString()

				schemaRegistryAuthenticationBasic = &shared.SchemaRegistryAuthenticationBasic{
					Username: username,
					Password: password,
				}
			}
			if schemaRegistryAuthenticationBasic != nil {
				authentication = &shared.SchemaRegistryAuthenticationScheme{
					SchemaRegistryAuthenticationBasic: schemaRegistryAuthenticationBasic,
				}
			}
		}
		config := shared.SchemaRegistryConfluentConfig{
			SchemaType:     schemaType,
			Endpoint:       endpoint,
			TimeoutSeconds: timeoutSeconds,
			Authentication: authentication,
		}
		labels := make(map[string]*string)
		for labelsKey, labelsValue := range r.Confluent.Labels {
			labelsInst := new(string)
			if !labelsValue.IsUnknown() && !labelsValue.IsNull() {
				*labelsInst = labelsValue.ValueString()
			} else {
				labelsInst = nil
			}
			labels[labelsKey] = labelsInst
		}
		schemaRegistryConfluent = &shared.SchemaRegistryConfluent{
			Name:        name,
			Description: description,
			Config:      config,
			Labels:      labels,
		}
	}
	if schemaRegistryConfluent != nil {
		out = shared.ModifySchemaRegistry{
			SchemaRegistryConfluent: schemaRegistryConfluent,
		}
	}

	return &out, diags
}
