// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"github.com/Kong/shared-speakeasy/customtypes/kumalabels"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/kong/terraform-provider-konnect-beta/internal/provider/typeconvert"
	tfTypes "github.com/kong/terraform-provider-konnect-beta/internal/provider/types"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/models/operations"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/models/shared"
)

func (r *MeshRetryResourceModel) RefreshFromSharedMeshRetryCreateOrUpdateSuccessResponse(ctx context.Context, resp *shared.MeshRetryCreateOrUpdateSuccessResponse) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.Warnings = make([]types.String, 0, len(resp.Warnings))
		for _, v := range resp.Warnings {
			r.Warnings = append(r.Warnings, types.StringValue(v))
		}
	}

	return diags
}

func (r *MeshRetryResourceModel) RefreshFromSharedMeshRetryItem(ctx context.Context, resp *shared.MeshRetryItem) diag.Diagnostics {
	var diags diag.Diagnostics

	if resp != nil {
		r.CreationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.CreationTime))
		r.Kri = types.StringPointerValue(resp.Kri)
		labelsValue, labelsDiags := types.MapValueFrom(ctx, types.StringType, resp.Labels)
		diags.Append(labelsDiags...)
		labelsValuable, labelsDiags := kumalabels.KumaLabelsMapType{MapType: types.MapType{ElemType: types.StringType}}.ValueFromMap(ctx, labelsValue)
		diags.Append(labelsDiags...)
		r.Labels, _ = labelsValuable.(kumalabels.KumaLabelsMapValue)
		r.Mesh = types.StringPointerValue(resp.Mesh)
		r.ModificationTime = types.StringPointerValue(typeconvert.TimePointerToStringPointer(resp.ModificationTime))
		r.Name = types.StringValue(resp.Name)
		if resp.Spec.TargetRef == nil {
			r.Spec.TargetRef = nil
		} else {
			r.Spec.TargetRef = &tfTypes.MeshAccessLogItemTargetRef{}
			r.Spec.TargetRef.Kind = types.StringValue(string(resp.Spec.TargetRef.Kind))
			if len(resp.Spec.TargetRef.Labels) > 0 {
				r.Spec.TargetRef.Labels = make(map[string]types.String, len(resp.Spec.TargetRef.Labels))
				for key, value := range resp.Spec.TargetRef.Labels {
					r.Spec.TargetRef.Labels[key] = types.StringValue(value)
				}
			}
			r.Spec.TargetRef.Mesh = types.StringPointerValue(resp.Spec.TargetRef.Mesh)
			r.Spec.TargetRef.Name = types.StringPointerValue(resp.Spec.TargetRef.Name)
			r.Spec.TargetRef.Namespace = types.StringPointerValue(resp.Spec.TargetRef.Namespace)
			r.Spec.TargetRef.ProxyTypes = make([]types.String, 0, len(resp.Spec.TargetRef.ProxyTypes))
			for _, v := range resp.Spec.TargetRef.ProxyTypes {
				r.Spec.TargetRef.ProxyTypes = append(r.Spec.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			r.Spec.TargetRef.SectionName = types.StringPointerValue(resp.Spec.TargetRef.SectionName)
			if len(resp.Spec.TargetRef.Tags) > 0 {
				r.Spec.TargetRef.Tags = make(map[string]types.String, len(resp.Spec.TargetRef.Tags))
				for key1, value1 := range resp.Spec.TargetRef.Tags {
					r.Spec.TargetRef.Tags[key1] = types.StringValue(value1)
				}
			}
		}
		r.Spec.To = []tfTypes.MeshRetryItemTo{}

		for _, toItem := range resp.Spec.To {
			var to tfTypes.MeshRetryItemTo

			if toItem.Default == nil {
				to.Default = nil
			} else {
				to.Default = &tfTypes.MeshRetryItemDefault{}
				if toItem.Default.Grpc == nil {
					to.Default.Grpc = nil
				} else {
					to.Default.Grpc = &tfTypes.MeshRetryItemGrpc{}
					if toItem.Default.Grpc.BackOff == nil {
						to.Default.Grpc.BackOff = nil
					} else {
						to.Default.Grpc.BackOff = &tfTypes.BackOff{}
						to.Default.Grpc.BackOff.BaseInterval = types.StringPointerValue(toItem.Default.Grpc.BackOff.BaseInterval)
						to.Default.Grpc.BackOff.MaxInterval = types.StringPointerValue(toItem.Default.Grpc.BackOff.MaxInterval)
					}
					to.Default.Grpc.NumRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.Grpc.NumRetries))
					to.Default.Grpc.PerTryTimeout = types.StringPointerValue(toItem.Default.Grpc.PerTryTimeout)
					if toItem.Default.Grpc.RateLimitedBackOff == nil {
						to.Default.Grpc.RateLimitedBackOff = nil
					} else {
						to.Default.Grpc.RateLimitedBackOff = &tfTypes.RateLimitedBackOff{}
						to.Default.Grpc.RateLimitedBackOff.MaxInterval = types.StringPointerValue(toItem.Default.Grpc.RateLimitedBackOff.MaxInterval)
						to.Default.Grpc.RateLimitedBackOff.ResetHeaders = []tfTypes.ResetHeaders{}

						for _, resetHeadersItem := range toItem.Default.Grpc.RateLimitedBackOff.ResetHeaders {
							var resetHeaders tfTypes.ResetHeaders

							resetHeaders.Format = types.StringValue(string(resetHeadersItem.Format))
							resetHeaders.Name = types.StringValue(resetHeadersItem.Name)

							to.Default.Grpc.RateLimitedBackOff.ResetHeaders = append(to.Default.Grpc.RateLimitedBackOff.ResetHeaders, resetHeaders)
						}
					}
					to.Default.Grpc.RetryOn = make([]types.String, 0, len(toItem.Default.Grpc.RetryOn))
					for _, v := range toItem.Default.Grpc.RetryOn {
						to.Default.Grpc.RetryOn = append(to.Default.Grpc.RetryOn, types.StringValue(string(v)))
					}
				}
				if toItem.Default.HTTP == nil {
					to.Default.HTTP = nil
				} else {
					to.Default.HTTP = &tfTypes.MeshRetryItemHTTP{}
					if toItem.Default.HTTP.BackOff == nil {
						to.Default.HTTP.BackOff = nil
					} else {
						to.Default.HTTP.BackOff = &tfTypes.BackOff{}
						to.Default.HTTP.BackOff.BaseInterval = types.StringPointerValue(toItem.Default.HTTP.BackOff.BaseInterval)
						to.Default.HTTP.BackOff.MaxInterval = types.StringPointerValue(toItem.Default.HTTP.BackOff.MaxInterval)
					}
					to.Default.HTTP.HostSelection = []tfTypes.HostSelection{}

					for _, hostSelectionItem := range toItem.Default.HTTP.HostSelection {
						var hostSelection tfTypes.HostSelection

						hostSelection.Predicate = types.StringValue(string(hostSelectionItem.Predicate))
						if len(hostSelectionItem.Tags) > 0 {
							hostSelection.Tags = make(map[string]types.String, len(hostSelectionItem.Tags))
							for key2, value2 := range hostSelectionItem.Tags {
								hostSelection.Tags[key2] = types.StringValue(value2)
							}
						}
						hostSelection.UpdateFrequency = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(hostSelectionItem.UpdateFrequency))

						to.Default.HTTP.HostSelection = append(to.Default.HTTP.HostSelection, hostSelection)
					}
					to.Default.HTTP.HostSelectionMaxAttempts = types.Int64PointerValue(toItem.Default.HTTP.HostSelectionMaxAttempts)
					to.Default.HTTP.NumRetries = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.HTTP.NumRetries))
					to.Default.HTTP.PerTryTimeout = types.StringPointerValue(toItem.Default.HTTP.PerTryTimeout)
					if toItem.Default.HTTP.RateLimitedBackOff == nil {
						to.Default.HTTP.RateLimitedBackOff = nil
					} else {
						to.Default.HTTP.RateLimitedBackOff = &tfTypes.RateLimitedBackOff{}
						to.Default.HTTP.RateLimitedBackOff.MaxInterval = types.StringPointerValue(toItem.Default.HTTP.RateLimitedBackOff.MaxInterval)
						to.Default.HTTP.RateLimitedBackOff.ResetHeaders = []tfTypes.ResetHeaders{}

						for _, resetHeadersItem1 := range toItem.Default.HTTP.RateLimitedBackOff.ResetHeaders {
							var resetHeaders1 tfTypes.ResetHeaders

							resetHeaders1.Format = types.StringValue(string(resetHeadersItem1.Format))
							resetHeaders1.Name = types.StringValue(resetHeadersItem1.Name)

							to.Default.HTTP.RateLimitedBackOff.ResetHeaders = append(to.Default.HTTP.RateLimitedBackOff.ResetHeaders, resetHeaders1)
						}
					}
					to.Default.HTTP.RetriableRequestHeaders = []tfTypes.Headers{}

					for _, retriableRequestHeadersItem := range toItem.Default.HTTP.RetriableRequestHeaders {
						var retriableRequestHeaders tfTypes.Headers

						retriableRequestHeaders.Name = types.StringValue(retriableRequestHeadersItem.Name)
						if retriableRequestHeadersItem.Type != nil {
							retriableRequestHeaders.Type = types.StringValue(string(*retriableRequestHeadersItem.Type))
						} else {
							retriableRequestHeaders.Type = types.StringNull()
						}
						retriableRequestHeaders.Value = types.StringPointerValue(retriableRequestHeadersItem.Value)

						to.Default.HTTP.RetriableRequestHeaders = append(to.Default.HTTP.RetriableRequestHeaders, retriableRequestHeaders)
					}
					to.Default.HTTP.RetriableResponseHeaders = []tfTypes.Headers{}

					for _, retriableResponseHeadersItem := range toItem.Default.HTTP.RetriableResponseHeaders {
						var retriableResponseHeaders tfTypes.Headers

						retriableResponseHeaders.Name = types.StringValue(retriableResponseHeadersItem.Name)
						if retriableResponseHeadersItem.Type != nil {
							retriableResponseHeaders.Type = types.StringValue(string(*retriableResponseHeadersItem.Type))
						} else {
							retriableResponseHeaders.Type = types.StringNull()
						}
						retriableResponseHeaders.Value = types.StringPointerValue(retriableResponseHeadersItem.Value)

						to.Default.HTTP.RetriableResponseHeaders = append(to.Default.HTTP.RetriableResponseHeaders, retriableResponseHeaders)
					}
					to.Default.HTTP.RetryOn = make([]types.String, 0, len(toItem.Default.HTTP.RetryOn))
					for _, v := range toItem.Default.HTTP.RetryOn {
						to.Default.HTTP.RetryOn = append(to.Default.HTTP.RetryOn, types.StringValue(v))
					}
				}
				if toItem.Default.TCP == nil {
					to.Default.TCP = nil
				} else {
					to.Default.TCP = &tfTypes.MeshRetryItemTCP{}
					to.Default.TCP.MaxConnectAttempt = types.Int32PointerValue(typeconvert.IntPointerToInt32Pointer(toItem.Default.TCP.MaxConnectAttempt))
				}
			}
			to.TargetRef.Kind = types.StringValue(string(toItem.TargetRef.Kind))
			if len(toItem.TargetRef.Labels) > 0 {
				to.TargetRef.Labels = make(map[string]types.String, len(toItem.TargetRef.Labels))
				for key3, value3 := range toItem.TargetRef.Labels {
					to.TargetRef.Labels[key3] = types.StringValue(value3)
				}
			}
			to.TargetRef.Mesh = types.StringPointerValue(toItem.TargetRef.Mesh)
			to.TargetRef.Name = types.StringPointerValue(toItem.TargetRef.Name)
			to.TargetRef.Namespace = types.StringPointerValue(toItem.TargetRef.Namespace)
			to.TargetRef.ProxyTypes = make([]types.String, 0, len(toItem.TargetRef.ProxyTypes))
			for _, v := range toItem.TargetRef.ProxyTypes {
				to.TargetRef.ProxyTypes = append(to.TargetRef.ProxyTypes, types.StringValue(string(v)))
			}
			to.TargetRef.SectionName = types.StringPointerValue(toItem.TargetRef.SectionName)
			if len(toItem.TargetRef.Tags) > 0 {
				to.TargetRef.Tags = make(map[string]types.String, len(toItem.TargetRef.Tags))
				for key4, value4 := range toItem.TargetRef.Tags {
					to.TargetRef.Tags[key4] = types.StringValue(value4)
				}
			}

			r.Spec.To = append(r.Spec.To, to)
		}
		r.Type = types.StringValue(string(resp.Type))
	}

	return diags
}

func (r *MeshRetryResourceModel) ToOperationsDeleteMeshRetryRequest(ctx context.Context) (*operations.DeleteMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cpID string
	cpID = r.CpID.ValueString()

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.DeleteMeshRetryRequest{
		CpID: cpID,
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToOperationsGetMeshRetryRequest(ctx context.Context) (*operations.GetMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cpID string
	cpID = r.CpID.ValueString()

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	out := operations.GetMeshRetryRequest{
		CpID: cpID,
		Mesh: mesh,
		Name: name,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToOperationsPutMeshRetryRequest(ctx context.Context) (*operations.PutMeshRetryRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	var cpID string
	cpID = r.CpID.ValueString()

	var mesh string
	mesh = r.Mesh.ValueString()

	var name string
	name = r.Name.ValueString()

	meshRetryItem, meshRetryItemDiags := r.ToSharedMeshRetryItemInput(ctx)
	diags.Append(meshRetryItemDiags...)

	if diags.HasError() {
		return nil, diags
	}

	out := operations.PutMeshRetryRequest{
		CpID:          cpID,
		Mesh:          mesh,
		Name:          name,
		MeshRetryItem: *meshRetryItem,
	}

	return &out, diags
}

func (r *MeshRetryResourceModel) ToSharedMeshRetryItemInput(ctx context.Context) (*shared.MeshRetryItemInput, diag.Diagnostics) {
	var diags diag.Diagnostics

	typeVar := shared.MeshRetryItemType(r.Type.ValueString())
	mesh := new(string)
	if !r.Mesh.IsUnknown() && !r.Mesh.IsNull() {
		*mesh = r.Mesh.ValueString()
	} else {
		mesh = nil
	}
	var name string
	name = r.Name.ValueString()

	var labels map[string]string
	if !r.Labels.IsUnknown() && !r.Labels.IsNull() {
		diags.Append(r.Labels.ElementsAs(ctx, &labels, true)...)
	}
	var targetRef *shared.MeshRetryItemTargetRef
	if r.Spec.TargetRef != nil {
		kind := shared.MeshRetryItemKind(r.Spec.TargetRef.Kind.ValueString())
		labels1 := make(map[string]string)
		for labelsKey := range r.Spec.TargetRef.Labels {
			var labelsInst string
			labelsInst = r.Spec.TargetRef.Labels[labelsKey].ValueString()

			labels1[labelsKey] = labelsInst
		}
		mesh1 := new(string)
		if !r.Spec.TargetRef.Mesh.IsUnknown() && !r.Spec.TargetRef.Mesh.IsNull() {
			*mesh1 = r.Spec.TargetRef.Mesh.ValueString()
		} else {
			mesh1 = nil
		}
		name1 := new(string)
		if !r.Spec.TargetRef.Name.IsUnknown() && !r.Spec.TargetRef.Name.IsNull() {
			*name1 = r.Spec.TargetRef.Name.ValueString()
		} else {
			name1 = nil
		}
		namespace := new(string)
		if !r.Spec.TargetRef.Namespace.IsUnknown() && !r.Spec.TargetRef.Namespace.IsNull() {
			*namespace = r.Spec.TargetRef.Namespace.ValueString()
		} else {
			namespace = nil
		}
		proxyTypes := make([]shared.MeshRetryItemProxyTypes, 0, len(r.Spec.TargetRef.ProxyTypes))
		for _, proxyTypesItem := range r.Spec.TargetRef.ProxyTypes {
			proxyTypes = append(proxyTypes, shared.MeshRetryItemProxyTypes(proxyTypesItem.ValueString()))
		}
		sectionName := new(string)
		if !r.Spec.TargetRef.SectionName.IsUnknown() && !r.Spec.TargetRef.SectionName.IsNull() {
			*sectionName = r.Spec.TargetRef.SectionName.ValueString()
		} else {
			sectionName = nil
		}
		tags := make(map[string]string)
		for tagsKey := range r.Spec.TargetRef.Tags {
			var tagsInst string
			tagsInst = r.Spec.TargetRef.Tags[tagsKey].ValueString()

			tags[tagsKey] = tagsInst
		}
		targetRef = &shared.MeshRetryItemTargetRef{
			Kind:        kind,
			Labels:      labels1,
			Mesh:        mesh1,
			Name:        name1,
			Namespace:   namespace,
			ProxyTypes:  proxyTypes,
			SectionName: sectionName,
			Tags:        tags,
		}
	}
	to := make([]shared.MeshRetryItemTo, 0, len(r.Spec.To))
	for toIndex := range r.Spec.To {
		var defaultVar *shared.MeshRetryItemDefault
		if r.Spec.To[toIndex].Default != nil {
			var grpc *shared.MeshRetryItemGrpc
			if r.Spec.To[toIndex].Default.Grpc != nil {
				var backOff *shared.BackOff
				if r.Spec.To[toIndex].Default.Grpc.BackOff != nil {
					baseInterval := new(string)
					if !r.Spec.To[toIndex].Default.Grpc.BackOff.BaseInterval.IsUnknown() && !r.Spec.To[toIndex].Default.Grpc.BackOff.BaseInterval.IsNull() {
						*baseInterval = r.Spec.To[toIndex].Default.Grpc.BackOff.BaseInterval.ValueString()
					} else {
						baseInterval = nil
					}
					maxInterval := new(string)
					if !r.Spec.To[toIndex].Default.Grpc.BackOff.MaxInterval.IsUnknown() && !r.Spec.To[toIndex].Default.Grpc.BackOff.MaxInterval.IsNull() {
						*maxInterval = r.Spec.To[toIndex].Default.Grpc.BackOff.MaxInterval.ValueString()
					} else {
						maxInterval = nil
					}
					backOff = &shared.BackOff{
						BaseInterval: baseInterval,
						MaxInterval:  maxInterval,
					}
				}
				numRetries := new(int)
				if !r.Spec.To[toIndex].Default.Grpc.NumRetries.IsUnknown() && !r.Spec.To[toIndex].Default.Grpc.NumRetries.IsNull() {
					*numRetries = int(r.Spec.To[toIndex].Default.Grpc.NumRetries.ValueInt32())
				} else {
					numRetries = nil
				}
				perTryTimeout := new(string)
				if !r.Spec.To[toIndex].Default.Grpc.PerTryTimeout.IsUnknown() && !r.Spec.To[toIndex].Default.Grpc.PerTryTimeout.IsNull() {
					*perTryTimeout = r.Spec.To[toIndex].Default.Grpc.PerTryTimeout.ValueString()
				} else {
					perTryTimeout = nil
				}
				var rateLimitedBackOff *shared.RateLimitedBackOff
				if r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff != nil {
					maxInterval1 := new(string)
					if !r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.MaxInterval.IsUnknown() && !r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.MaxInterval.IsNull() {
						*maxInterval1 = r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.MaxInterval.ValueString()
					} else {
						maxInterval1 = nil
					}
					resetHeaders := make([]shared.ResetHeaders, 0, len(r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.ResetHeaders))
					for resetHeadersIndex := range r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.ResetHeaders {
						format := shared.MeshRetryItemFormat(r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.ResetHeaders[resetHeadersIndex].Format.ValueString())
						var name2 string
						name2 = r.Spec.To[toIndex].Default.Grpc.RateLimitedBackOff.ResetHeaders[resetHeadersIndex].Name.ValueString()

						resetHeaders = append(resetHeaders, shared.ResetHeaders{
							Format: format,
							Name:   name2,
						})
					}
					rateLimitedBackOff = &shared.RateLimitedBackOff{
						MaxInterval:  maxInterval1,
						ResetHeaders: resetHeaders,
					}
				}
				retryOn := make([]shared.RetryOn, 0, len(r.Spec.To[toIndex].Default.Grpc.RetryOn))
				for _, retryOnItem := range r.Spec.To[toIndex].Default.Grpc.RetryOn {
					retryOn = append(retryOn, shared.RetryOn(retryOnItem.ValueString()))
				}
				grpc = &shared.MeshRetryItemGrpc{
					BackOff:            backOff,
					NumRetries:         numRetries,
					PerTryTimeout:      perTryTimeout,
					RateLimitedBackOff: rateLimitedBackOff,
					RetryOn:            retryOn,
				}
			}
			var http *shared.MeshRetryItemHTTP
			if r.Spec.To[toIndex].Default.HTTP != nil {
				var backOff1 *shared.MeshRetryItemBackOff
				if r.Spec.To[toIndex].Default.HTTP.BackOff != nil {
					baseInterval1 := new(string)
					if !r.Spec.To[toIndex].Default.HTTP.BackOff.BaseInterval.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.BackOff.BaseInterval.IsNull() {
						*baseInterval1 = r.Spec.To[toIndex].Default.HTTP.BackOff.BaseInterval.ValueString()
					} else {
						baseInterval1 = nil
					}
					maxInterval2 := new(string)
					if !r.Spec.To[toIndex].Default.HTTP.BackOff.MaxInterval.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.BackOff.MaxInterval.IsNull() {
						*maxInterval2 = r.Spec.To[toIndex].Default.HTTP.BackOff.MaxInterval.ValueString()
					} else {
						maxInterval2 = nil
					}
					backOff1 = &shared.MeshRetryItemBackOff{
						BaseInterval: baseInterval1,
						MaxInterval:  maxInterval2,
					}
				}
				hostSelection := make([]shared.HostSelection, 0, len(r.Spec.To[toIndex].Default.HTTP.HostSelection))
				for hostSelectionIndex := range r.Spec.To[toIndex].Default.HTTP.HostSelection {
					predicate := shared.Predicate(r.Spec.To[toIndex].Default.HTTP.HostSelection[hostSelectionIndex].Predicate.ValueString())
					tags1 := make(map[string]string)
					for tagsKey1 := range r.Spec.To[toIndex].Default.HTTP.HostSelection[hostSelectionIndex].Tags {
						var tagsInst1 string
						tagsInst1 = r.Spec.To[toIndex].Default.HTTP.HostSelection[hostSelectionIndex].Tags[tagsKey1].ValueString()

						tags1[tagsKey1] = tagsInst1
					}
					updateFrequency := new(int)
					if !r.Spec.To[toIndex].Default.HTTP.HostSelection[hostSelectionIndex].UpdateFrequency.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.HostSelection[hostSelectionIndex].UpdateFrequency.IsNull() {
						*updateFrequency = int(r.Spec.To[toIndex].Default.HTTP.HostSelection[hostSelectionIndex].UpdateFrequency.ValueInt32())
					} else {
						updateFrequency = nil
					}
					hostSelection = append(hostSelection, shared.HostSelection{
						Predicate:       predicate,
						Tags:            tags1,
						UpdateFrequency: updateFrequency,
					})
				}
				hostSelectionMaxAttempts := new(int64)
				if !r.Spec.To[toIndex].Default.HTTP.HostSelectionMaxAttempts.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.HostSelectionMaxAttempts.IsNull() {
					*hostSelectionMaxAttempts = r.Spec.To[toIndex].Default.HTTP.HostSelectionMaxAttempts.ValueInt64()
				} else {
					hostSelectionMaxAttempts = nil
				}
				numRetries1 := new(int)
				if !r.Spec.To[toIndex].Default.HTTP.NumRetries.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.NumRetries.IsNull() {
					*numRetries1 = int(r.Spec.To[toIndex].Default.HTTP.NumRetries.ValueInt32())
				} else {
					numRetries1 = nil
				}
				perTryTimeout1 := new(string)
				if !r.Spec.To[toIndex].Default.HTTP.PerTryTimeout.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.PerTryTimeout.IsNull() {
					*perTryTimeout1 = r.Spec.To[toIndex].Default.HTTP.PerTryTimeout.ValueString()
				} else {
					perTryTimeout1 = nil
				}
				var rateLimitedBackOff1 *shared.MeshRetryItemRateLimitedBackOff
				if r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff != nil {
					maxInterval3 := new(string)
					if !r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.MaxInterval.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.MaxInterval.IsNull() {
						*maxInterval3 = r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.MaxInterval.ValueString()
					} else {
						maxInterval3 = nil
					}
					resetHeaders1 := make([]shared.MeshRetryItemResetHeaders, 0, len(r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.ResetHeaders))
					for resetHeadersIndex1 := range r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.ResetHeaders {
						format1 := shared.MeshRetryItemSpecFormat(r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.ResetHeaders[resetHeadersIndex1].Format.ValueString())
						var name3 string
						name3 = r.Spec.To[toIndex].Default.HTTP.RateLimitedBackOff.ResetHeaders[resetHeadersIndex1].Name.ValueString()

						resetHeaders1 = append(resetHeaders1, shared.MeshRetryItemResetHeaders{
							Format: format1,
							Name:   name3,
						})
					}
					rateLimitedBackOff1 = &shared.MeshRetryItemRateLimitedBackOff{
						MaxInterval:  maxInterval3,
						ResetHeaders: resetHeaders1,
					}
				}
				retriableRequestHeaders := make([]shared.RetriableRequestHeaders, 0, len(r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders))
				for retriableRequestHeadersIndex := range r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders {
					var name4 string
					name4 = r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Name.ValueString()

					type1 := new(shared.MeshRetryItemSpecType)
					if !r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Type.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Type.IsNull() {
						*type1 = shared.MeshRetryItemSpecType(r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Type.ValueString())
					} else {
						type1 = nil
					}
					value := new(string)
					if !r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Value.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Value.IsNull() {
						*value = r.Spec.To[toIndex].Default.HTTP.RetriableRequestHeaders[retriableRequestHeadersIndex].Value.ValueString()
					} else {
						value = nil
					}
					retriableRequestHeaders = append(retriableRequestHeaders, shared.RetriableRequestHeaders{
						Name:  name4,
						Type:  type1,
						Value: value,
					})
				}
				retriableResponseHeaders := make([]shared.RetriableResponseHeaders, 0, len(r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders))
				for retriableResponseHeadersIndex := range r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders {
					var name5 string
					name5 = r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Name.ValueString()

					type2 := new(shared.MeshRetryItemSpecToType)
					if !r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Type.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Type.IsNull() {
						*type2 = shared.MeshRetryItemSpecToType(r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Type.ValueString())
					} else {
						type2 = nil
					}
					value1 := new(string)
					if !r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Value.IsUnknown() && !r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Value.IsNull() {
						*value1 = r.Spec.To[toIndex].Default.HTTP.RetriableResponseHeaders[retriableResponseHeadersIndex].Value.ValueString()
					} else {
						value1 = nil
					}
					retriableResponseHeaders = append(retriableResponseHeaders, shared.RetriableResponseHeaders{
						Name:  name5,
						Type:  type2,
						Value: value1,
					})
				}
				retryOn1 := make([]string, 0, len(r.Spec.To[toIndex].Default.HTTP.RetryOn))
				for retryOnIndex := range r.Spec.To[toIndex].Default.HTTP.RetryOn {
					retryOn1 = append(retryOn1, r.Spec.To[toIndex].Default.HTTP.RetryOn[retryOnIndex].ValueString())
				}
				http = &shared.MeshRetryItemHTTP{
					BackOff:                  backOff1,
					HostSelection:            hostSelection,
					HostSelectionMaxAttempts: hostSelectionMaxAttempts,
					NumRetries:               numRetries1,
					PerTryTimeout:            perTryTimeout1,
					RateLimitedBackOff:       rateLimitedBackOff1,
					RetriableRequestHeaders:  retriableRequestHeaders,
					RetriableResponseHeaders: retriableResponseHeaders,
					RetryOn:                  retryOn1,
				}
			}
			var tcp *shared.MeshRetryItemTCP
			if r.Spec.To[toIndex].Default.TCP != nil {
				maxConnectAttempt := new(int)
				if !r.Spec.To[toIndex].Default.TCP.MaxConnectAttempt.IsUnknown() && !r.Spec.To[toIndex].Default.TCP.MaxConnectAttempt.IsNull() {
					*maxConnectAttempt = int(r.Spec.To[toIndex].Default.TCP.MaxConnectAttempt.ValueInt32())
				} else {
					maxConnectAttempt = nil
				}
				tcp = &shared.MeshRetryItemTCP{
					MaxConnectAttempt: maxConnectAttempt,
				}
			}
			defaultVar = &shared.MeshRetryItemDefault{
				Grpc: grpc,
				HTTP: http,
				TCP:  tcp,
			}
		}
		kind1 := shared.MeshRetryItemSpecKind(r.Spec.To[toIndex].TargetRef.Kind.ValueString())
		labels2 := make(map[string]string)
		for labelsKey1 := range r.Spec.To[toIndex].TargetRef.Labels {
			var labelsInst1 string
			labelsInst1 = r.Spec.To[toIndex].TargetRef.Labels[labelsKey1].ValueString()

			labels2[labelsKey1] = labelsInst1
		}
		mesh2 := new(string)
		if !r.Spec.To[toIndex].TargetRef.Mesh.IsUnknown() && !r.Spec.To[toIndex].TargetRef.Mesh.IsNull() {
			*mesh2 = r.Spec.To[toIndex].TargetRef.Mesh.ValueString()
		} else {
			mesh2 = nil
		}
		name6 := new(string)
		if !r.Spec.To[toIndex].TargetRef.Name.IsUnknown() && !r.Spec.To[toIndex].TargetRef.Name.IsNull() {
			*name6 = r.Spec.To[toIndex].TargetRef.Name.ValueString()
		} else {
			name6 = nil
		}
		namespace1 := new(string)
		if !r.Spec.To[toIndex].TargetRef.Namespace.IsUnknown() && !r.Spec.To[toIndex].TargetRef.Namespace.IsNull() {
			*namespace1 = r.Spec.To[toIndex].TargetRef.Namespace.ValueString()
		} else {
			namespace1 = nil
		}
		proxyTypes1 := make([]shared.MeshRetryItemSpecProxyTypes, 0, len(r.Spec.To[toIndex].TargetRef.ProxyTypes))
		for _, proxyTypesItem1 := range r.Spec.To[toIndex].TargetRef.ProxyTypes {
			proxyTypes1 = append(proxyTypes1, shared.MeshRetryItemSpecProxyTypes(proxyTypesItem1.ValueString()))
		}
		sectionName1 := new(string)
		if !r.Spec.To[toIndex].TargetRef.SectionName.IsUnknown() && !r.Spec.To[toIndex].TargetRef.SectionName.IsNull() {
			*sectionName1 = r.Spec.To[toIndex].TargetRef.SectionName.ValueString()
		} else {
			sectionName1 = nil
		}
		tags2 := make(map[string]string)
		for tagsKey2 := range r.Spec.To[toIndex].TargetRef.Tags {
			var tagsInst2 string
			tagsInst2 = r.Spec.To[toIndex].TargetRef.Tags[tagsKey2].ValueString()

			tags2[tagsKey2] = tagsInst2
		}
		targetRef1 := shared.MeshRetryItemSpecTargetRef{
			Kind:        kind1,
			Labels:      labels2,
			Mesh:        mesh2,
			Name:        name6,
			Namespace:   namespace1,
			ProxyTypes:  proxyTypes1,
			SectionName: sectionName1,
			Tags:        tags2,
		}
		to = append(to, shared.MeshRetryItemTo{
			Default:   defaultVar,
			TargetRef: targetRef1,
		})
	}
	spec := shared.MeshRetryItemSpec{
		TargetRef: targetRef,
		To:        to,
	}
	out := shared.MeshRetryItemInput{
		Type:   typeVar,
		Mesh:   mesh,
		Name:   name,
		Labels: labels,
		Spec:   spec,
	}

	return &out, diags
}
