// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/internal/utils"
)

type ForwardToVirtualClusterPolicyConfigType string

const (
	ForwardToVirtualClusterPolicyConfigTypePortMapping ForwardToVirtualClusterPolicyConfigType = "port_mapping"
	ForwardToVirtualClusterPolicyConfigTypeSni         ForwardToVirtualClusterPolicyConfigType = "sni"
)

type ForwardToVirtualClusterPolicyConfig struct {
	ForwardToClusterBySNIConfig         *ForwardToClusterBySNIConfig         `queryParam:"inline"`
	ForwardToClusterByPortMappingConfig *ForwardToClusterByPortMappingConfig `queryParam:"inline"`

	Type ForwardToVirtualClusterPolicyConfigType
}

func CreateForwardToVirtualClusterPolicyConfigPortMapping(portMapping ForwardToClusterByPortMappingConfig) ForwardToVirtualClusterPolicyConfig {
	typ := ForwardToVirtualClusterPolicyConfigTypePortMapping

	return ForwardToVirtualClusterPolicyConfig{
		ForwardToClusterByPortMappingConfig: &portMapping,
		Type:                                typ,
	}
}

func CreateForwardToVirtualClusterPolicyConfigSni(sni ForwardToClusterBySNIConfig) ForwardToVirtualClusterPolicyConfig {
	typ := ForwardToVirtualClusterPolicyConfigTypeSni

	return ForwardToVirtualClusterPolicyConfig{
		ForwardToClusterBySNIConfig: &sni,
		Type:                        typ,
	}
}

func (u *ForwardToVirtualClusterPolicyConfig) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "port_mapping":
		forwardToClusterByPortMappingConfig := new(ForwardToClusterByPortMappingConfig)
		if err := utils.UnmarshalJSON(data, &forwardToClusterByPortMappingConfig, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == port_mapping) type ForwardToClusterByPortMappingConfig within ForwardToVirtualClusterPolicyConfig: %w", string(data), err)
		}

		u.ForwardToClusterByPortMappingConfig = forwardToClusterByPortMappingConfig
		u.Type = ForwardToVirtualClusterPolicyConfigTypePortMapping
		return nil
	case "sni":
		forwardToClusterBySNIConfig := new(ForwardToClusterBySNIConfig)
		if err := utils.UnmarshalJSON(data, &forwardToClusterBySNIConfig, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == sni) type ForwardToClusterBySNIConfig within ForwardToVirtualClusterPolicyConfig: %w", string(data), err)
		}

		u.ForwardToClusterBySNIConfig = forwardToClusterBySNIConfig
		u.Type = ForwardToVirtualClusterPolicyConfigTypeSni
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ForwardToVirtualClusterPolicyConfig", string(data))
}

func (u ForwardToVirtualClusterPolicyConfig) MarshalJSON() ([]byte, error) {
	if u.ForwardToClusterBySNIConfig != nil {
		return utils.MarshalJSON(u.ForwardToClusterBySNIConfig, "", true)
	}

	if u.ForwardToClusterByPortMappingConfig != nil {
		return utils.MarshalJSON(u.ForwardToClusterByPortMappingConfig, "", true)
	}

	return nil, errors.New("could not marshal union type ForwardToVirtualClusterPolicyConfig: all fields are null")
}

// ForwardToVirtualClusterPolicy - Forwards requests to virtual clusters configured with port routing or SNI routing.
// While there can be multiple of these policies configured on a listener, there can only be one instance of
// `port_mapping`.
// When multiple policies are configured, the first one that matches the connection is used.
// If no policy matches, the connection is rejected.
//
// When using `port_mapping`, there must be a mapping port for each broker on the backend cluster see
// `ForwardToClusterBySNIConfig` for more details.
type ForwardToVirtualClusterPolicy struct {
	type_ string `const:"forward_to_virtual_cluster" json:"type"`
	// A unique user-defined name of the policy.
	Name *string `default:"null" json:"name"`
	// A human-readable description of the policy.
	Description *string `json:"description,omitempty"`
	// Whether the policy is enabled.
	Enabled *bool                               `default:"true" json:"enabled"`
	Config  ForwardToVirtualClusterPolicyConfig `json:"config"`
	// Labels store metadata of an entity that can be used for filtering an entity list or for searching across entity types.
	//
	// Keys must be of length 1-63 characters, and cannot start with "kong", "konnect", "mesh", "kic", or "_".
	//
	Labels map[string]*string `json:"labels,omitempty"`
}

func (f ForwardToVirtualClusterPolicy) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *ForwardToVirtualClusterPolicy) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ForwardToVirtualClusterPolicy) GetType() string {
	return "forward_to_virtual_cluster"
}

func (o *ForwardToVirtualClusterPolicy) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ForwardToVirtualClusterPolicy) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ForwardToVirtualClusterPolicy) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *ForwardToVirtualClusterPolicy) GetConfig() ForwardToVirtualClusterPolicyConfig {
	if o == nil {
		return ForwardToVirtualClusterPolicyConfig{}
	}
	return o.Config
}

func (o *ForwardToVirtualClusterPolicy) GetConfigPortMapping() *ForwardToClusterByPortMappingConfig {
	return o.GetConfig().ForwardToClusterByPortMappingConfig
}

func (o *ForwardToVirtualClusterPolicy) GetConfigSni() *ForwardToClusterBySNIConfig {
	return o.GetConfig().ForwardToClusterBySNIConfig
}

func (o *ForwardToVirtualClusterPolicy) GetLabels() map[string]*string {
	if o == nil {
		return nil
	}
	return o.Labels
}
