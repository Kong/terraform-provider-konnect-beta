// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type MetricsRelativeTimeRangeDtoV2Type string

const (
	MetricsRelativeTimeRangeDtoV2TypeRelative MetricsRelativeTimeRangeDtoV2Type = "relative"
)

func (e MetricsRelativeTimeRangeDtoV2Type) ToPointer() *MetricsRelativeTimeRangeDtoV2Type {
	return &e
}
func (e *MetricsRelativeTimeRangeDtoV2Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "relative":
		*e = MetricsRelativeTimeRangeDtoV2Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MetricsRelativeTimeRangeDtoV2Type: %v", v)
	}
}

type MetricsRelativeTimeRangeDtoV2TimeRange string

const (
	MetricsRelativeTimeRangeDtoV2TimeRangeFifteenm      MetricsRelativeTimeRangeDtoV2TimeRange = "15m"
	MetricsRelativeTimeRangeDtoV2TimeRangeOneh          MetricsRelativeTimeRangeDtoV2TimeRange = "1h"
	MetricsRelativeTimeRangeDtoV2TimeRangeSixh          MetricsRelativeTimeRangeDtoV2TimeRange = "6h"
	MetricsRelativeTimeRangeDtoV2TimeRangeTwelveh       MetricsRelativeTimeRangeDtoV2TimeRange = "12h"
	MetricsRelativeTimeRangeDtoV2TimeRangeTwentyFourh   MetricsRelativeTimeRangeDtoV2TimeRange = "24h"
	MetricsRelativeTimeRangeDtoV2TimeRangeSevend        MetricsRelativeTimeRangeDtoV2TimeRange = "7d"
	MetricsRelativeTimeRangeDtoV2TimeRangeThirtyd       MetricsRelativeTimeRangeDtoV2TimeRange = "30d"
	MetricsRelativeTimeRangeDtoV2TimeRangeCurrentWeek   MetricsRelativeTimeRangeDtoV2TimeRange = "current_week"
	MetricsRelativeTimeRangeDtoV2TimeRangeCurrentMonth  MetricsRelativeTimeRangeDtoV2TimeRange = "current_month"
	MetricsRelativeTimeRangeDtoV2TimeRangePreviousWeek  MetricsRelativeTimeRangeDtoV2TimeRange = "previous_week"
	MetricsRelativeTimeRangeDtoV2TimeRangePreviousMonth MetricsRelativeTimeRangeDtoV2TimeRange = "previous_month"
)

func (e MetricsRelativeTimeRangeDtoV2TimeRange) ToPointer() *MetricsRelativeTimeRangeDtoV2TimeRange {
	return &e
}
func (e *MetricsRelativeTimeRangeDtoV2TimeRange) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "15m":
		fallthrough
	case "1h":
		fallthrough
	case "6h":
		fallthrough
	case "12h":
		fallthrough
	case "24h":
		fallthrough
	case "7d":
		fallthrough
	case "30d":
		fallthrough
	case "current_week":
		fallthrough
	case "current_month":
		fallthrough
	case "previous_week":
		fallthrough
	case "previous_month":
		*e = MetricsRelativeTimeRangeDtoV2TimeRange(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MetricsRelativeTimeRangeDtoV2TimeRange: %v", v)
	}
}

// MetricsRelativeTimeRangeDtoV2 - A duration representing a relative-to-now span of time. Generally the start time is floored to the requested granularity. Eg 7d from now, with 1day granularity initiated at 2024-01-08T17:11:00+05:00 will query for the time range from 2024-01-01T00:00:00+05:00 to 2024-01-08T17:11:00+05:00. The exact start and end timestamps are returned in the result query in the meta.start and meta.end fields. If the granularity for the previous query was 1hour, it would query a time range from 2024-01-01T17:00:00+05:00 to 2024-01-08T17:11:00+05:00.
type MetricsRelativeTimeRangeDtoV2 struct {
	Tz        *string                                `json:"tz,omitempty"`
	Type      MetricsRelativeTimeRangeDtoV2Type      `json:"type"`
	TimeRange MetricsRelativeTimeRangeDtoV2TimeRange `json:"time_range"`
}

func (o *MetricsRelativeTimeRangeDtoV2) GetTz() *string {
	if o == nil {
		return nil
	}
	return o.Tz
}

func (o *MetricsRelativeTimeRangeDtoV2) GetType() MetricsRelativeTimeRangeDtoV2Type {
	if o == nil {
		return MetricsRelativeTimeRangeDtoV2Type("")
	}
	return o.Type
}

func (o *MetricsRelativeTimeRangeDtoV2) GetTimeRange() MetricsRelativeTimeRangeDtoV2TimeRange {
	if o == nil {
		return MetricsRelativeTimeRangeDtoV2TimeRange("")
	}
	return o.TimeRange
}
