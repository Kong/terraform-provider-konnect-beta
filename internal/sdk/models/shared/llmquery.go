// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type LLMQueryDatasource string

const (
	LLMQueryDatasourceLlmUsage LLMQueryDatasource = "llm_usage"
)

func (e LLMQueryDatasource) ToPointer() *LLMQueryDatasource {
	return &e
}
func (e *LLMQueryDatasource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "llm_usage":
		*e = LLMQueryDatasource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LLMQueryDatasource: %v", v)
	}
}

type LLMQueryDimensions string

const (
	LLMQueryDimensionsControlPlane          LLMQueryDimensions = "control_plane"
	LLMQueryDimensionsControlPlaneGroup     LLMQueryDimensions = "control_plane_group"
	LLMQueryDimensionsGatewayService        LLMQueryDimensions = "gateway_service"
	LLMQueryDimensionsConsumer              LLMQueryDimensions = "consumer"
	LLMQueryDimensionsApplication           LLMQueryDimensions = "application"
	LLMQueryDimensionsRoute                 LLMQueryDimensions = "route"
	LLMQueryDimensionsAiProvider            LLMQueryDimensions = "ai_provider"
	LLMQueryDimensionsAiResponseModel       LLMQueryDimensions = "ai_response_model"
	LLMQueryDimensionsAiRequestModel        LLMQueryDimensions = "ai_request_model"
	LLMQueryDimensionsLlmCacheStatus        LLMQueryDimensions = "llm_cache_status"
	LLMQueryDimensionsLlmEmbeddingsProvider LLMQueryDimensions = "llm_embeddings_provider"
	LLMQueryDimensionsLlmEmbeddingsModel    LLMQueryDimensions = "llm_embeddings_model"
	LLMQueryDimensionsTime                  LLMQueryDimensions = "time"
	LLMQueryDimensionsRealm                 LLMQueryDimensions = "realm"
	LLMQueryDimensionsStatusCode            LLMQueryDimensions = "status_code"
	LLMQueryDimensionsStatusCodeGrouped     LLMQueryDimensions = "status_code_grouped"
	LLMQueryDimensionsAiPlugin              LLMQueryDimensions = "ai_plugin"
)

func (e LLMQueryDimensions) ToPointer() *LLMQueryDimensions {
	return &e
}
func (e *LLMQueryDimensions) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "control_plane":
		fallthrough
	case "control_plane_group":
		fallthrough
	case "gateway_service":
		fallthrough
	case "consumer":
		fallthrough
	case "application":
		fallthrough
	case "route":
		fallthrough
	case "ai_provider":
		fallthrough
	case "ai_response_model":
		fallthrough
	case "ai_request_model":
		fallthrough
	case "llm_cache_status":
		fallthrough
	case "llm_embeddings_provider":
		fallthrough
	case "llm_embeddings_model":
		fallthrough
	case "time":
		fallthrough
	case "realm":
		fallthrough
	case "status_code":
		fallthrough
	case "status_code_grouped":
		fallthrough
	case "ai_plugin":
		*e = LLMQueryDimensions(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LLMQueryDimensions: %v", v)
	}
}

// LLMQuery - A query targeting the LLM usage analytics datasource.
type LLMQuery struct {
	Datasource LLMQueryDatasource `json:"datasource"`
	// List of aggregated metrics to collect across the requested time span.
	Metrics []LLMMetrics `json:"metrics,omitempty"`
	// List of attributes or entity types to group by.
	Dimensions []LLMQueryDimensions `json:"dimensions,omitempty"`
	// A list of filters to apply to the query.
	Filters []LLMFilters `json:"filters,omitempty"`
	// Force time grouping into buckets of the specified duration.  Only has an effect if "time" is in the "dimensions" list.
	//
	// The granularity of the result may be coarser than requested.  The finest allowed granularity depends on the query's time range: data farther in the past may have coarser granularity.  The exact result granularity will be reported in the response `meta.granularity_ms` field.
	//
	// If granularity is not specified and "time" is in the dimensions list, a default will be chosen based on the time range requested.
	//
	// Different relative times support different granularities:
	//
	//   - 15m => tenSecondly, thirtySecondly, minutely
	//   - 1h  => tenSecondly, thirtySecondly, minutely, fiveMinutely, tenMinutely
	//   - 6h  => thirtySecondly, minutely, fiveMinutely, tenMinutely, thirtyMinutely, hourly
	//   - 12h => minutely, fiveMinutely, tenMinutely, thirtyMinutely, hourly
	//   - 24h => fiveMinutely, tenMinutely, thirtyMinutely, hourly
	//   - 7d  => thirtyMinutely, hourly, twoHourly, twelveHourly, daily
	//   - 30d => hourly, twoHourly, twelveHourly, daily, weekly
	//
	// For special time ranges:
	//
	//   - current_week, previous_week   => thirtyMinutely, hourly, twoHourly, twelveHourly, daily
	//   - current_month, previous_month => hourly, twoHourly, twelveHourly, daily, weekly
	//
	// For absolute time ranges, daily will be used.
	//
	Granularity *Granularity `json:"granularity,omitempty"`
	// The time range to query.
	TimeRange *TimeRange `json:"time_range,omitempty"`
}

func (o *LLMQuery) GetDatasource() LLMQueryDatasource {
	if o == nil {
		return LLMQueryDatasource("")
	}
	return o.Datasource
}

func (o *LLMQuery) GetMetrics() []LLMMetrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

func (o *LLMQuery) GetDimensions() []LLMQueryDimensions {
	if o == nil {
		return nil
	}
	return o.Dimensions
}

func (o *LLMQuery) GetFilters() []LLMFilters {
	if o == nil {
		return nil
	}
	return o.Filters
}

func (o *LLMQuery) GetGranularity() *Granularity {
	if o == nil {
		return nil
	}
	return o.Granularity
}

func (o *LLMQuery) GetTimeRange() *TimeRange {
	if o == nil {
		return nil
	}
	return o.TimeRange
}

func (o *LLMQuery) GetTimeRangeRelative() *MetricsRelativeTimeRangeDtoV2 {
	if v := o.GetTimeRange(); v != nil {
		return v.MetricsRelativeTimeRangeDtoV2
	}
	return nil
}

func (o *LLMQuery) GetTimeRangeAbsolute() *MetricsAbsoluteTimeRangeDtoV2 {
	if v := o.GetTimeRange(); v != nil {
		return v.MetricsAbsoluteTimeRangeDtoV2
	}
	return nil
}
