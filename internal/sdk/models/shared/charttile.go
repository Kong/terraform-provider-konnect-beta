// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/internal/utils"
)

// Position of the tile in the dashboard's grid.  Numbering starts at 0, so a tile in the upper left of the dashboard will be at column 0, row 0.
type Position struct {
	Col int64 `json:"col"`
	Row int64 `json:"row"`
}

func (p Position) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *Position) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"col", "row"}); err != nil {
		return err
	}
	return nil
}

func (p *Position) GetCol() int64 {
	if p == nil {
		return 0
	}
	return p.Col
}

func (p *Position) GetRow() int64 {
	if p == nil {
		return 0
	}
	return p.Row
}

// Size - Number of columns and rows the tile occupies.  A dashboard always has 6 columns, but has as many rows as needed to accommodate the given tiles.
type Size struct {
	Cols int64 `json:"cols"`
	Rows int64 `json:"rows"`
}

func (s Size) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Size) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"cols", "rows"}); err != nil {
		return err
	}
	return nil
}

func (s *Size) GetCols() int64 {
	if s == nil {
		return 0
	}
	return s.Cols
}

func (s *Size) GetRows() int64 {
	if s == nil {
		return 0
	}
	return s.Rows
}

// Layout - Information about how the tile is placed on the dashboard.
//
// Examples:
// - a tile occupying the first half of the top row: `{ "position": { "col": 0, "row": 0 }, size: { "cols": 3, "rows": 1 } }`
// - a tile occupying the second half of the top row: `{ "position": { "col": 3, "row": 0 }, size: { "cols": 3, "rows": 1 } }`
type Layout struct {
	// Position of the tile in the dashboard's grid.  Numbering starts at 0, so a tile in the upper left of the dashboard will be at column 0, row 0.
	//
	Position Position `json:"position"`
	// Number of columns and rows the tile occupies.  A dashboard always has 6 columns, but has as many rows as needed to accommodate the given tiles.
	//
	Size Size `json:"size"`
}

func (l Layout) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *Layout) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"position", "size"}); err != nil {
		return err
	}
	return nil
}

func (l *Layout) GetPosition() Position {
	if l == nil {
		return Position{}
	}
	return l.Position
}

func (l *Layout) GetSize() Size {
	if l == nil {
		return Size{}
	}
	return l.Size
}

// ChartTileType - The type of tile.  Chart tiles must have type 'chart'.
type ChartTileType string

const (
	ChartTileTypeChart ChartTileType = "chart"
)

func (e ChartTileType) ToPointer() *ChartTileType {
	return &e
}
func (e *ChartTileType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "chart":
		*e = ChartTileType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChartTileType: %v", v)
	}
}

type QueryType string

const (
	QueryTypeAPIUsage QueryType = "api_usage"
	QueryTypeLlmUsage QueryType = "llm_usage"
)

type Query struct {
	AdvancedQuery *AdvancedQuery `queryParam:"inline,name=query"`
	LLMQuery      *LLMQuery      `queryParam:"inline,name=query"`

	Type QueryType
}

func CreateQueryAPIUsage(apiUsage AdvancedQuery) Query {
	typ := QueryTypeAPIUsage

	typStr := Datasource(typ)
	apiUsage.Datasource = typStr

	return Query{
		AdvancedQuery: &apiUsage,
		Type:          typ,
	}
}

func CreateQueryLlmUsage(llmUsage LLMQuery) Query {
	typ := QueryTypeLlmUsage

	typStr := LLMQueryDatasource(typ)
	llmUsage.Datasource = typStr

	return Query{
		LLMQuery: &llmUsage,
		Type:     typ,
	}
}

func (u *Query) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Datasource string `json:"datasource"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Datasource {
	case "api_usage":
		advancedQuery := new(AdvancedQuery)
		if err := utils.UnmarshalJSON(data, &advancedQuery, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Datasource == api_usage) type AdvancedQuery within Query: %w", string(data), err)
		}

		u.AdvancedQuery = advancedQuery
		u.Type = QueryTypeAPIUsage
		return nil
	case "llm_usage":
		llmQuery := new(LLMQuery)
		if err := utils.UnmarshalJSON(data, &llmQuery, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Datasource == llm_usage) type LLMQuery within Query: %w", string(data), err)
		}

		u.LLMQuery = llmQuery
		u.Type = QueryTypeLlmUsage
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Query", string(data))
}

func (u Query) MarshalJSON() ([]byte, error) {
	if u.AdvancedQuery != nil {
		return utils.MarshalJSON(u.AdvancedQuery, "", true)
	}

	if u.LLMQuery != nil {
		return utils.MarshalJSON(u.LLMQuery, "", true)
	}

	return nil, errors.New("could not marshal union type Query: all fields are null")
}

// Definition - The tile's definition, which consists of a query to fetch data and a chart to render the data.
// Note that some charts expect certain types of queries to render properly.  The documentation for the individual chart types has more information.
type Definition struct {
	Query Query `json:"query"`
	// The type of chart to render.
	Chart Chart `json:"chart"`
}

func (d Definition) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Definition) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"query", "chart"}); err != nil {
		return err
	}
	return nil
}

func (d *Definition) GetQuery() Query {
	if d == nil {
		return Query{}
	}
	return d.Query
}

func (d *Definition) GetQueryAPIUsage() *AdvancedQuery {
	return d.GetQuery().AdvancedQuery
}

func (d *Definition) GetQueryLlmUsage() *LLMQuery {
	return d.GetQuery().LLMQuery
}

func (d *Definition) GetChart() Chart {
	if d == nil {
		return Chart{}
	}
	return d.Chart
}

func (d *Definition) GetChartDonut() *DonutChart {
	return d.GetChart().DonutChart
}

func (d *Definition) GetChartTimeseriesLine() *TimeseriesChart {
	return d.GetChart().TimeseriesChart
}

func (d *Definition) GetChartTimeseriesBar() *TimeseriesChart {
	return d.GetChart().TimeseriesChart
}

func (d *Definition) GetChartHorizontalBar() *BarChart {
	return d.GetChart().BarChart
}

func (d *Definition) GetChartVerticalBar() *BarChart {
	return d.GetChart().BarChart
}

func (d *Definition) GetChartSingleValue() *SingleValueChart {
	return d.GetChart().SingleValueChart
}

// ChartTile - A tile that queries data and renders a chart.
type ChartTile struct {
	// Information about how the tile is placed on the dashboard.
	//
	// Examples:
	// - a tile occupying the first half of the top row: `{ "position": { "col": 0, "row": 0 }, size: { "cols": 3, "rows": 1 } }`
	// - a tile occupying the second half of the top row: `{ "position": { "col": 3, "row": 0 }, size: { "cols": 3, "rows": 1 } }`
	//
	Layout Layout `json:"layout"`
	// The type of tile.  Chart tiles must have type 'chart'.
	Type ChartTileType `json:"type"`
	// The tile's definition, which consists of a query to fetch data and a chart to render the data.
	// Note that some charts expect certain types of queries to render properly.  The documentation for the individual chart types has more information.
	//
	Definition Definition `json:"definition"`
}

func (c ChartTile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ChartTile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"layout", "type", "definition"}); err != nil {
		return err
	}
	return nil
}

func (c *ChartTile) GetLayout() Layout {
	if c == nil {
		return Layout{}
	}
	return c.Layout
}

func (c *ChartTile) GetType() ChartTileType {
	if c == nil {
		return ChartTileType("")
	}
	return c.Type
}

func (c *ChartTile) GetDefinition() Definition {
	if c == nil {
		return Definition{}
	}
	return c.Definition
}
