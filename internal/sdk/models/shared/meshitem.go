// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package shared

import (
	"errors"
	"fmt"
	"github.com/kong/terraform-provider-konnect-beta/internal/sdk/internal/utils"
)

// Requirements - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Requirements struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Requirements) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// Restrictions - Rules defines a set of rules for data plane proxies to be member of the mesh.
type Restrictions struct {
	// Tags defines set of required tags. You can specify '*' in value to
	// require non empty value of tag
	Tags map[string]string `json:"tags,omitempty"`
}

func (o *Restrictions) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

// DataplaneProxy - DataplaneProxyMembership defines a set of requirements for data plane
// proxies to be a member of the mesh.
type DataplaneProxy struct {
	// Requirements defines a set of requirements that data plane proxies must
	// fulfill in order to join the mesh. A data plane proxy must fulfill at
	// least one requirement in order to join the mesh. Empty list of allowed
	// requirements means that any proxy that is not explicitly denied can join.
	Requirements []Requirements `json:"requirements,omitempty"`
	// Restrictions defines a set of restrictions that data plane proxies cannot
	// fulfill in order to join the mesh. A data plane proxy cannot fulfill any
	// requirement in order to join the mesh.
	// Restrictions takes precedence over requirements.
	Restrictions []Restrictions `json:"restrictions,omitempty"`
}

func (o *DataplaneProxy) GetRequirements() []Requirements {
	if o == nil {
		return nil
	}
	return o.Requirements
}

func (o *DataplaneProxy) GetRestrictions() []Restrictions {
	if o == nil {
		return nil
	}
	return o.Restrictions
}

// Constraints that applies to the mesh and its entities
type Constraints struct {
	// DataplaneProxyMembership defines a set of requirements for data plane
	// proxies to be a member of the mesh.
	DataplaneProxy *DataplaneProxy `json:"dataplaneProxy,omitempty"`
}

func (o *Constraints) GetDataplaneProxy() *DataplaneProxy {
	if o == nil {
		return nil
	}
	return o.DataplaneProxy
}

// TCPLoggingBackendConfig - TcpLoggingBackendConfig defines configuration for TCP based access logs
type TCPLoggingBackendConfig struct {
	// Address to TCP service that will receive logs
	Address *string `json:"address,omitempty"`
}

func (o *TCPLoggingBackendConfig) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

// FileLoggingBackendConfig defines configuration for file based access logs
type FileLoggingBackendConfig struct {
	// Path to a file that logs will be written to
	Path *string `json:"path,omitempty"`
}

func (o *FileLoggingBackendConfig) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

type MeshItemLoggingConfType string

const (
	MeshItemLoggingConfTypeFileLoggingBackendConfig MeshItemLoggingConfType = "FileLoggingBackendConfig"
	MeshItemLoggingConfTypeTCPLoggingBackendConfig  MeshItemLoggingConfType = "TcpLoggingBackendConfig"
)

type MeshItemLoggingConf struct {
	FileLoggingBackendConfig *FileLoggingBackendConfig `queryParam:"inline"`
	TCPLoggingBackendConfig  *TCPLoggingBackendConfig  `queryParam:"inline"`

	Type MeshItemLoggingConfType
}

func CreateMeshItemLoggingConfFileLoggingBackendConfig(fileLoggingBackendConfig FileLoggingBackendConfig) MeshItemLoggingConf {
	typ := MeshItemLoggingConfTypeFileLoggingBackendConfig

	return MeshItemLoggingConf{
		FileLoggingBackendConfig: &fileLoggingBackendConfig,
		Type:                     typ,
	}
}

func CreateMeshItemLoggingConfTCPLoggingBackendConfig(tcpLoggingBackendConfig TCPLoggingBackendConfig) MeshItemLoggingConf {
	typ := MeshItemLoggingConfTypeTCPLoggingBackendConfig

	return MeshItemLoggingConf{
		TCPLoggingBackendConfig: &tcpLoggingBackendConfig,
		Type:                    typ,
	}
}

func (u *MeshItemLoggingConf) UnmarshalJSON(data []byte) error {

	var fileLoggingBackendConfig FileLoggingBackendConfig = FileLoggingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &fileLoggingBackendConfig, "", true, true); err == nil {
		u.FileLoggingBackendConfig = &fileLoggingBackendConfig
		u.Type = MeshItemLoggingConfTypeFileLoggingBackendConfig
		return nil
	}

	var tcpLoggingBackendConfig TCPLoggingBackendConfig = TCPLoggingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &tcpLoggingBackendConfig, "", true, true); err == nil {
		u.TCPLoggingBackendConfig = &tcpLoggingBackendConfig
		u.Type = MeshItemLoggingConfTypeTCPLoggingBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemLoggingConf", string(data))
}

func (u MeshItemLoggingConf) MarshalJSON() ([]byte, error) {
	if u.FileLoggingBackendConfig != nil {
		return utils.MarshalJSON(u.FileLoggingBackendConfig, "", true)
	}

	if u.TCPLoggingBackendConfig != nil {
		return utils.MarshalJSON(u.TCPLoggingBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemLoggingConf: all fields are null")
}

// Backends - LoggingBackend defines logging backend available to mesh.
type Backends struct {
	Conf *MeshItemLoggingConf `json:"conf,omitempty"`
	// Format of access logs. Placeholders available on
	// https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log
	Format *string `json:"format,omitempty"`
	// Name of the backend, can be then used in Mesh.logging.defaultBackend or in
	// TrafficLogging
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'tcp' and 'file')
	Type *string `json:"type,omitempty"`
}

func (o *Backends) GetConf() *MeshItemLoggingConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *Backends) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *Backends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Backends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Logging settings.
// +optional
type Logging struct {
	// List of available logging backends
	Backends []Backends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Logging) GetBackends() []Backends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Logging) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

type MeshItemModeType string

const (
	MeshItemModeTypeStr     MeshItemModeType = "str"
	MeshItemModeTypeInteger MeshItemModeType = "integer"
)

type MeshItemMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type MeshItemModeType
}

func CreateMeshItemModeStr(str string) MeshItemMode {
	typ := MeshItemModeTypeStr

	return MeshItemMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateMeshItemModeInteger(integer int64) MeshItemMode {
	typ := MeshItemModeTypeInteger

	return MeshItemMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *MeshItemMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshItemModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshItemModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMode", string(data))
}

func (u MeshItemMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMode: all fields are null")
}

type MeshServices struct {
	Mode *MeshItemMode `json:"mode,omitempty"`
}

func (o *MeshServices) GetMode() *MeshItemMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

// Aggregate - PrometheusAggregateMetricsConfig defines endpoints that should be scrapped by kuma-dp for prometheus metrics.
type Aggregate struct {
	// Address on which a service expose HTTP endpoint with Prometheus metrics.
	Address *string `json:"address,omitempty"`
	// If false then the application won't be scrapped. If nil, then it is treated
	// as true and kuma-dp scrapes metrics from the service.
	Enabled *bool `json:"enabled,omitempty"`
	// Name which identify given configuration.
	Name *string `json:"name,omitempty"`
	// Path on which a service expose HTTP endpoint with Prometheus metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a service expose HTTP endpoint with Prometheus metrics.
	Port *int64 `json:"port,omitempty"`
}

func (o *Aggregate) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *Aggregate) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *Aggregate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Aggregate) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *Aggregate) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

// Envoy - Configuration of Envoy's metrics.
type Envoy struct {
	// FilterRegex value that is going to be passed to Envoy for filtering
	// Envoy metrics.
	FilterRegex *string `json:"filterRegex,omitempty"`
	// If true then return metrics that Envoy has updated (counters incremented
	// at least once, gauges changed at least once, and histograms added to at
	// least once). If nil, then it is treated as false.
	UsedOnly *bool `json:"usedOnly,omitempty"`
}

func (o *Envoy) GetFilterRegex() *string {
	if o == nil {
		return nil
	}
	return o.FilterRegex
}

func (o *Envoy) GetUsedOnly() *bool {
	if o == nil {
		return nil
	}
	return o.UsedOnly
}

type ConfModeType string

const (
	ConfModeTypeStr     ConfModeType = "str"
	ConfModeTypeInteger ConfModeType = "integer"
)

// ConfMode - mode defines how configured is the TLS for Prometheus.
// Supported values, delegated, disabled, activeMTLSBackend. Default to
// `activeMTLSBackend`.
type ConfMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type ConfModeType
}

func CreateConfModeStr(str string) ConfMode {
	typ := ConfModeTypeStr

	return ConfMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateConfModeInteger(integer int64) ConfMode {
	typ := ConfModeTypeInteger

	return ConfMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *ConfMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ConfModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = ConfModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfMode", string(data))
}

func (u ConfMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type ConfMode: all fields are null")
}

// ConfTLS - Configuration of TLS for prometheus listener.
type ConfTLS struct {
	// mode defines how configured is the TLS for Prometheus.
	// Supported values, delegated, disabled, activeMTLSBackend. Default to
	// `activeMTLSBackend`.
	Mode *ConfMode `json:"mode,omitempty"`
}

func (o *ConfTLS) GetMode() *ConfMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

// PrometheusMetricsBackendConfig defines configuration of Prometheus backend
type PrometheusMetricsBackendConfig struct {
	// Map with the configuration of applications which metrics are going to be
	// scrapped by kuma-dp.
	Aggregate []Aggregate `json:"aggregate,omitempty"`
	// Configuration of Envoy's metrics.
	Envoy *Envoy `json:"envoy,omitempty"`
	// Path on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Path *string `json:"path,omitempty"`
	// Port on which a dataplane should expose HTTP endpoint with Prometheus
	// metrics.
	Port *int64 `json:"port,omitempty"`
	// If true then endpoints for scraping metrics won't require mTLS even if mTLS
	// is enabled in Mesh. If nil, then it is treated as false.
	SkipMTLS *bool `json:"skipMTLS,omitempty"`
	// Tags associated with an application this dataplane is deployed next to,
	// e.g. service=web, version=1.0.
	// `service` tag is mandatory.
	Tags map[string]string `json:"tags,omitempty"`
	// Configuration of TLS for prometheus listener.
	TLS *ConfTLS `json:"tls,omitempty"`
}

func (o *PrometheusMetricsBackendConfig) GetAggregate() []Aggregate {
	if o == nil {
		return nil
	}
	return o.Aggregate
}

func (o *PrometheusMetricsBackendConfig) GetEnvoy() *Envoy {
	if o == nil {
		return nil
	}
	return o.Envoy
}

func (o *PrometheusMetricsBackendConfig) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *PrometheusMetricsBackendConfig) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *PrometheusMetricsBackendConfig) GetSkipMTLS() *bool {
	if o == nil {
		return nil
	}
	return o.SkipMTLS
}

func (o *PrometheusMetricsBackendConfig) GetTags() map[string]string {
	if o == nil {
		return nil
	}
	return o.Tags
}

func (o *PrometheusMetricsBackendConfig) GetTLS() *ConfTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

type MeshItemConfType string

const (
	MeshItemConfTypePrometheusMetricsBackendConfig MeshItemConfType = "PrometheusMetricsBackendConfig"
)

type MeshItemConf struct {
	PrometheusMetricsBackendConfig *PrometheusMetricsBackendConfig `queryParam:"inline"`

	Type MeshItemConfType
}

func CreateMeshItemConfPrometheusMetricsBackendConfig(prometheusMetricsBackendConfig PrometheusMetricsBackendConfig) MeshItemConf {
	typ := MeshItemConfTypePrometheusMetricsBackendConfig

	return MeshItemConf{
		PrometheusMetricsBackendConfig: &prometheusMetricsBackendConfig,
		Type:                           typ,
	}
}

func (u *MeshItemConf) UnmarshalJSON(data []byte) error {

	var prometheusMetricsBackendConfig PrometheusMetricsBackendConfig = PrometheusMetricsBackendConfig{}
	if err := utils.UnmarshalJSON(data, &prometheusMetricsBackendConfig, "", true, true); err == nil {
		u.PrometheusMetricsBackendConfig = &prometheusMetricsBackendConfig
		u.Type = MeshItemConfTypePrometheusMetricsBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemConf", string(data))
}

func (u MeshItemConf) MarshalJSON() ([]byte, error) {
	if u.PrometheusMetricsBackendConfig != nil {
		return utils.MarshalJSON(u.PrometheusMetricsBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemConf: all fields are null")
}

// MeshItemBackends - MetricsBackend defines metric backends
type MeshItemBackends struct {
	Conf *MeshItemConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.metrics.enabledBackend
	Name *string `json:"name,omitempty"`
	// Type of the backend (Kuma ships with 'prometheus')
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemBackends) GetConf() *MeshItemConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Metrics - Configuration for metrics collected and exposed by dataplanes.
//
// Settings defined here become defaults for every dataplane in a given Mesh.
// Additionally, it is also possible to further customize this configuration
// for each dataplane individually using Dataplane resource.
// +optional
type Metrics struct {
	// List of available Metrics backends
	Backends []MeshItemBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
}

func (o *Metrics) GetBackends() []MeshItemBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Metrics) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *CertManagerCertificateAuthorityConfigCaCertDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *CertManagerCertificateAuthorityConfigCaCertDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type CertManagerCertificateAuthorityConfigCaCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *CertManagerCertificateAuthorityConfigCaCertDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type CertManagerCertificateAuthorityConfigConfCaCertType string

const (
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile         CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_File"
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline       CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_Inline"
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_InlineString"
	CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret       CertManagerCertificateAuthorityConfigConfCaCertType = "CertManagerCertificateAuthorityConfig_caCert_DataSource_Secret"
)

type CertManagerCertificateAuthorityConfigConfCaCert struct {
	CertManagerCertificateAuthorityConfigCaCertDataSourceFile         *CertManagerCertificateAuthorityConfigCaCertDataSourceFile         `queryParam:"inline"`
	CertManagerCertificateAuthorityConfigCaCertDataSourceInline       *CertManagerCertificateAuthorityConfigCaCertDataSourceInline       `queryParam:"inline"`
	CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString *CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString `queryParam:"inline"`
	CertManagerCertificateAuthorityConfigCaCertDataSourceSecret       *CertManagerCertificateAuthorityConfigCaCertDataSourceSecret       `queryParam:"inline"`

	Type CertManagerCertificateAuthorityConfigConfCaCertType
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceFile(certManagerCertificateAuthorityConfigCaCertDataSourceFile CertManagerCertificateAuthorityConfigCaCertDataSourceFile) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceFile: &certManagerCertificateAuthorityConfigCaCertDataSourceFile,
		Type: typ,
	}
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceInline(certManagerCertificateAuthorityConfigCaCertDataSourceInline CertManagerCertificateAuthorityConfigCaCertDataSourceInline) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceInline: &certManagerCertificateAuthorityConfigCaCertDataSourceInline,
		Type: typ,
	}
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString(certManagerCertificateAuthorityConfigCaCertDataSourceInlineString CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString: &certManagerCertificateAuthorityConfigCaCertDataSourceInlineString,
		Type: typ,
	}
}

func CreateCertManagerCertificateAuthorityConfigConfCaCertCertManagerCertificateAuthorityConfigCaCertDataSourceSecret(certManagerCertificateAuthorityConfigCaCertDataSourceSecret CertManagerCertificateAuthorityConfigCaCertDataSourceSecret) CertManagerCertificateAuthorityConfigConfCaCert {
	typ := CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret

	return CertManagerCertificateAuthorityConfigConfCaCert{
		CertManagerCertificateAuthorityConfigCaCertDataSourceSecret: &certManagerCertificateAuthorityConfigCaCertDataSourceSecret,
		Type: typ,
	}
}

func (u *CertManagerCertificateAuthorityConfigConfCaCert) UnmarshalJSON(data []byte) error {

	var certManagerCertificateAuthorityConfigCaCertDataSourceFile CertManagerCertificateAuthorityConfigCaCertDataSourceFile = CertManagerCertificateAuthorityConfigCaCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceFile, "", true, true); err == nil {
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceFile = &certManagerCertificateAuthorityConfigCaCertDataSourceFile
		u.Type = CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceFile
		return nil
	}

	var certManagerCertificateAuthorityConfigCaCertDataSourceInline CertManagerCertificateAuthorityConfigCaCertDataSourceInline = CertManagerCertificateAuthorityConfigCaCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceInline, "", true, true); err == nil {
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceInline = &certManagerCertificateAuthorityConfigCaCertDataSourceInline
		u.Type = CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInline
		return nil
	}

	var certManagerCertificateAuthorityConfigCaCertDataSourceInlineString CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString = CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceInlineString, "", true, true); err == nil {
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString = &certManagerCertificateAuthorityConfigCaCertDataSourceInlineString
		u.Type = CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceInlineString
		return nil
	}

	var certManagerCertificateAuthorityConfigCaCertDataSourceSecret CertManagerCertificateAuthorityConfigCaCertDataSourceSecret = CertManagerCertificateAuthorityConfigCaCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfigCaCertDataSourceSecret, "", true, true); err == nil {
		u.CertManagerCertificateAuthorityConfigCaCertDataSourceSecret = &certManagerCertificateAuthorityConfigCaCertDataSourceSecret
		u.Type = CertManagerCertificateAuthorityConfigConfCaCertTypeCertManagerCertificateAuthorityConfigCaCertDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CertManagerCertificateAuthorityConfigConfCaCert", string(data))
}

func (u CertManagerCertificateAuthorityConfigConfCaCert) MarshalJSON() ([]byte, error) {
	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceFile != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceFile, "", true)
	}

	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceInline != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceInline, "", true)
	}

	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceInlineString, "", true)
	}

	if u.CertManagerCertificateAuthorityConfigCaCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfigCaCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type CertManagerCertificateAuthorityConfigConfCaCert: all fields are null")
}

type IssuerRef struct {
	Group *string `json:"group,omitempty"`
	Kind  *string `json:"kind,omitempty"`
	Name  *string `json:"name,omitempty"`
}

func (o *IssuerRef) GetGroup() *string {
	if o == nil {
		return nil
	}
	return o.Group
}

func (o *IssuerRef) GetKind() *string {
	if o == nil {
		return nil
	}
	return o.Kind
}

func (o *IssuerRef) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

type CertManagerCertificateAuthorityConfig struct {
	CaCert     *CertManagerCertificateAuthorityConfigConfCaCert `json:"caCert,omitempty"`
	CommonName *string                                          `json:"commonName,omitempty"`
	DNSNames   []string                                         `json:"dnsNames,omitempty"`
	IssuerRef  *IssuerRef                                       `json:"issuerRef,omitempty"`
}

func (o *CertManagerCertificateAuthorityConfig) GetCaCert() *CertManagerCertificateAuthorityConfigConfCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

func (o *CertManagerCertificateAuthorityConfig) GetCommonName() *string {
	if o == nil {
		return nil
	}
	return o.CommonName
}

func (o *CertManagerCertificateAuthorityConfig) GetDNSNames() []string {
	if o == nil {
		return nil
	}
	return o.DNSNames
}

func (o *CertManagerCertificateAuthorityConfig) GetIssuerRef() *IssuerRef {
	if o == nil {
		return nil
	}
	return o.IssuerRef
}

type AccessKeyDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *AccessKeyDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type AccessKeyDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *AccessKeyDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type AccessKeyDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *AccessKeyDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type AccessKeyDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *AccessKeyDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type AccessKeyType string

const (
	AccessKeyTypeAccessKeyDataSourceFile         AccessKeyType = "accessKey_DataSource_File"
	AccessKeyTypeAccessKeyDataSourceInline       AccessKeyType = "accessKey_DataSource_Inline"
	AccessKeyTypeAccessKeyDataSourceInlineString AccessKeyType = "accessKey_DataSource_InlineString"
	AccessKeyTypeAccessKeyDataSourceSecret       AccessKeyType = "accessKey_DataSource_Secret"
)

type AccessKey struct {
	AccessKeyDataSourceFile         *AccessKeyDataSourceFile         `queryParam:"inline"`
	AccessKeyDataSourceInline       *AccessKeyDataSourceInline       `queryParam:"inline"`
	AccessKeyDataSourceInlineString *AccessKeyDataSourceInlineString `queryParam:"inline"`
	AccessKeyDataSourceSecret       *AccessKeyDataSourceSecret       `queryParam:"inline"`

	Type AccessKeyType
}

func CreateAccessKeyAccessKeyDataSourceFile(accessKeyDataSourceFile AccessKeyDataSourceFile) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceFile

	return AccessKey{
		AccessKeyDataSourceFile: &accessKeyDataSourceFile,
		Type:                    typ,
	}
}

func CreateAccessKeyAccessKeyDataSourceInline(accessKeyDataSourceInline AccessKeyDataSourceInline) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceInline

	return AccessKey{
		AccessKeyDataSourceInline: &accessKeyDataSourceInline,
		Type:                      typ,
	}
}

func CreateAccessKeyAccessKeyDataSourceInlineString(accessKeyDataSourceInlineString AccessKeyDataSourceInlineString) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceInlineString

	return AccessKey{
		AccessKeyDataSourceInlineString: &accessKeyDataSourceInlineString,
		Type:                            typ,
	}
}

func CreateAccessKeyAccessKeyDataSourceSecret(accessKeyDataSourceSecret AccessKeyDataSourceSecret) AccessKey {
	typ := AccessKeyTypeAccessKeyDataSourceSecret

	return AccessKey{
		AccessKeyDataSourceSecret: &accessKeyDataSourceSecret,
		Type:                      typ,
	}
}

func (u *AccessKey) UnmarshalJSON(data []byte) error {

	var accessKeyDataSourceFile AccessKeyDataSourceFile = AccessKeyDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceFile, "", true, true); err == nil {
		u.AccessKeyDataSourceFile = &accessKeyDataSourceFile
		u.Type = AccessKeyTypeAccessKeyDataSourceFile
		return nil
	}

	var accessKeyDataSourceInline AccessKeyDataSourceInline = AccessKeyDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceInline, "", true, true); err == nil {
		u.AccessKeyDataSourceInline = &accessKeyDataSourceInline
		u.Type = AccessKeyTypeAccessKeyDataSourceInline
		return nil
	}

	var accessKeyDataSourceInlineString AccessKeyDataSourceInlineString = AccessKeyDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceInlineString, "", true, true); err == nil {
		u.AccessKeyDataSourceInlineString = &accessKeyDataSourceInlineString
		u.Type = AccessKeyTypeAccessKeyDataSourceInlineString
		return nil
	}

	var accessKeyDataSourceSecret AccessKeyDataSourceSecret = AccessKeyDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &accessKeyDataSourceSecret, "", true, true); err == nil {
		u.AccessKeyDataSourceSecret = &accessKeyDataSourceSecret
		u.Type = AccessKeyTypeAccessKeyDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKey", string(data))
}

func (u AccessKey) MarshalJSON() ([]byte, error) {
	if u.AccessKeyDataSourceFile != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceFile, "", true)
	}

	if u.AccessKeyDataSourceInline != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceInline, "", true)
	}

	if u.AccessKeyDataSourceInlineString != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceInlineString, "", true)
	}

	if u.AccessKeyDataSourceSecret != nil {
		return utils.MarshalJSON(u.AccessKeyDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AccessKey: all fields are null")
}

type AccessKeySecretDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *AccessKeySecretDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type AccessKeySecretDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *AccessKeySecretDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type AccessKeySecretDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *AccessKeySecretDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type AccessKeySecretDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *AccessKeySecretDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type AccessKeySecretType string

const (
	AccessKeySecretTypeAccessKeySecretDataSourceFile         AccessKeySecretType = "accessKeySecret_DataSource_File"
	AccessKeySecretTypeAccessKeySecretDataSourceInline       AccessKeySecretType = "accessKeySecret_DataSource_Inline"
	AccessKeySecretTypeAccessKeySecretDataSourceInlineString AccessKeySecretType = "accessKeySecret_DataSource_InlineString"
	AccessKeySecretTypeAccessKeySecretDataSourceSecret       AccessKeySecretType = "accessKeySecret_DataSource_Secret"
)

type AccessKeySecret struct {
	AccessKeySecretDataSourceFile         *AccessKeySecretDataSourceFile         `queryParam:"inline"`
	AccessKeySecretDataSourceInline       *AccessKeySecretDataSourceInline       `queryParam:"inline"`
	AccessKeySecretDataSourceInlineString *AccessKeySecretDataSourceInlineString `queryParam:"inline"`
	AccessKeySecretDataSourceSecret       *AccessKeySecretDataSourceSecret       `queryParam:"inline"`

	Type AccessKeySecretType
}

func CreateAccessKeySecretAccessKeySecretDataSourceFile(accessKeySecretDataSourceFile AccessKeySecretDataSourceFile) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceFile

	return AccessKeySecret{
		AccessKeySecretDataSourceFile: &accessKeySecretDataSourceFile,
		Type:                          typ,
	}
}

func CreateAccessKeySecretAccessKeySecretDataSourceInline(accessKeySecretDataSourceInline AccessKeySecretDataSourceInline) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceInline

	return AccessKeySecret{
		AccessKeySecretDataSourceInline: &accessKeySecretDataSourceInline,
		Type:                            typ,
	}
}

func CreateAccessKeySecretAccessKeySecretDataSourceInlineString(accessKeySecretDataSourceInlineString AccessKeySecretDataSourceInlineString) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceInlineString

	return AccessKeySecret{
		AccessKeySecretDataSourceInlineString: &accessKeySecretDataSourceInlineString,
		Type:                                  typ,
	}
}

func CreateAccessKeySecretAccessKeySecretDataSourceSecret(accessKeySecretDataSourceSecret AccessKeySecretDataSourceSecret) AccessKeySecret {
	typ := AccessKeySecretTypeAccessKeySecretDataSourceSecret

	return AccessKeySecret{
		AccessKeySecretDataSourceSecret: &accessKeySecretDataSourceSecret,
		Type:                            typ,
	}
}

func (u *AccessKeySecret) UnmarshalJSON(data []byte) error {

	var accessKeySecretDataSourceFile AccessKeySecretDataSourceFile = AccessKeySecretDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceFile, "", true, true); err == nil {
		u.AccessKeySecretDataSourceFile = &accessKeySecretDataSourceFile
		u.Type = AccessKeySecretTypeAccessKeySecretDataSourceFile
		return nil
	}

	var accessKeySecretDataSourceInline AccessKeySecretDataSourceInline = AccessKeySecretDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceInline, "", true, true); err == nil {
		u.AccessKeySecretDataSourceInline = &accessKeySecretDataSourceInline
		u.Type = AccessKeySecretTypeAccessKeySecretDataSourceInline
		return nil
	}

	var accessKeySecretDataSourceInlineString AccessKeySecretDataSourceInlineString = AccessKeySecretDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceInlineString, "", true, true); err == nil {
		u.AccessKeySecretDataSourceInlineString = &accessKeySecretDataSourceInlineString
		u.Type = AccessKeySecretTypeAccessKeySecretDataSourceInlineString
		return nil
	}

	var accessKeySecretDataSourceSecret AccessKeySecretDataSourceSecret = AccessKeySecretDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &accessKeySecretDataSourceSecret, "", true, true); err == nil {
		u.AccessKeySecretDataSourceSecret = &accessKeySecretDataSourceSecret
		u.Type = AccessKeySecretTypeAccessKeySecretDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AccessKeySecret", string(data))
}

func (u AccessKeySecret) MarshalJSON() ([]byte, error) {
	if u.AccessKeySecretDataSourceFile != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceFile, "", true)
	}

	if u.AccessKeySecretDataSourceInline != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceInline, "", true)
	}

	if u.AccessKeySecretDataSourceInlineString != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceInlineString, "", true)
	}

	if u.AccessKeySecretDataSourceSecret != nil {
		return utils.MarshalJSON(u.AccessKeySecretDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AccessKeySecret: all fields are null")
}

type AwsCredentials struct {
	AccessKey       *AccessKey       `json:"accessKey,omitempty"`
	AccessKeySecret *AccessKeySecret `json:"accessKeySecret,omitempty"`
}

func (o *AwsCredentials) GetAccessKey() *AccessKey {
	if o == nil {
		return nil
	}
	return o.AccessKey
}

func (o *AwsCredentials) GetAccessKeySecret() *AccessKeySecret {
	if o == nil {
		return nil
	}
	return o.AccessKeySecret
}

type Auth struct {
	AwsCredentials *AwsCredentials `json:"awsCredentials,omitempty"`
}

func (o *Auth) GetAwsCredentials() *AwsCredentials {
	if o == nil {
		return nil
	}
	return o.AwsCredentials
}

type CaCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *CaCertDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type CaCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *CaCertDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type CaCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *CaCertDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type CaCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *CaCertDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type ConfCaCertType string

const (
	ConfCaCertTypeCaCertDataSourceFile         ConfCaCertType = "caCert_DataSource_File"
	ConfCaCertTypeCaCertDataSourceInline       ConfCaCertType = "caCert_DataSource_Inline"
	ConfCaCertTypeCaCertDataSourceInlineString ConfCaCertType = "caCert_DataSource_InlineString"
	ConfCaCertTypeCaCertDataSourceSecret       ConfCaCertType = "caCert_DataSource_Secret"
)

type ConfCaCert struct {
	CaCertDataSourceFile         *CaCertDataSourceFile         `queryParam:"inline"`
	CaCertDataSourceInline       *CaCertDataSourceInline       `queryParam:"inline"`
	CaCertDataSourceInlineString *CaCertDataSourceInlineString `queryParam:"inline"`
	CaCertDataSourceSecret       *CaCertDataSourceSecret       `queryParam:"inline"`

	Type ConfCaCertType
}

func CreateConfCaCertCaCertDataSourceFile(caCertDataSourceFile CaCertDataSourceFile) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceFile

	return ConfCaCert{
		CaCertDataSourceFile: &caCertDataSourceFile,
		Type:                 typ,
	}
}

func CreateConfCaCertCaCertDataSourceInline(caCertDataSourceInline CaCertDataSourceInline) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceInline

	return ConfCaCert{
		CaCertDataSourceInline: &caCertDataSourceInline,
		Type:                   typ,
	}
}

func CreateConfCaCertCaCertDataSourceInlineString(caCertDataSourceInlineString CaCertDataSourceInlineString) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceInlineString

	return ConfCaCert{
		CaCertDataSourceInlineString: &caCertDataSourceInlineString,
		Type:                         typ,
	}
}

func CreateConfCaCertCaCertDataSourceSecret(caCertDataSourceSecret CaCertDataSourceSecret) ConfCaCert {
	typ := ConfCaCertTypeCaCertDataSourceSecret

	return ConfCaCert{
		CaCertDataSourceSecret: &caCertDataSourceSecret,
		Type:                   typ,
	}
}

func (u *ConfCaCert) UnmarshalJSON(data []byte) error {

	var caCertDataSourceFile CaCertDataSourceFile = CaCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceFile, "", true, true); err == nil {
		u.CaCertDataSourceFile = &caCertDataSourceFile
		u.Type = ConfCaCertTypeCaCertDataSourceFile
		return nil
	}

	var caCertDataSourceInline CaCertDataSourceInline = CaCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceInline, "", true, true); err == nil {
		u.CaCertDataSourceInline = &caCertDataSourceInline
		u.Type = ConfCaCertTypeCaCertDataSourceInline
		return nil
	}

	var caCertDataSourceInlineString CaCertDataSourceInlineString = CaCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceInlineString, "", true, true); err == nil {
		u.CaCertDataSourceInlineString = &caCertDataSourceInlineString
		u.Type = ConfCaCertTypeCaCertDataSourceInlineString
		return nil
	}

	var caCertDataSourceSecret CaCertDataSourceSecret = CaCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &caCertDataSourceSecret, "", true, true); err == nil {
		u.CaCertDataSourceSecret = &caCertDataSourceSecret
		u.Type = ConfCaCertTypeCaCertDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConfCaCert", string(data))
}

func (u ConfCaCert) MarshalJSON() ([]byte, error) {
	if u.CaCertDataSourceFile != nil {
		return utils.MarshalJSON(u.CaCertDataSourceFile, "", true)
	}

	if u.CaCertDataSourceInline != nil {
		return utils.MarshalJSON(u.CaCertDataSourceInline, "", true)
	}

	if u.CaCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.CaCertDataSourceInlineString, "", true)
	}

	if u.CaCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.CaCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type ConfCaCert: all fields are null")
}

type ACMCertificateAuthorityConfig struct {
	Arn        *string     `json:"arn,omitempty"`
	Auth       *Auth       `json:"auth,omitempty"`
	CaCert     *ConfCaCert `json:"caCert,omitempty"`
	CommonName *string     `json:"commonName,omitempty"`
}

func (o *ACMCertificateAuthorityConfig) GetArn() *string {
	if o == nil {
		return nil
	}
	return o.Arn
}

func (o *ACMCertificateAuthorityConfig) GetAuth() *Auth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *ACMCertificateAuthorityConfig) GetCaCert() *ConfCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

func (o *ACMCertificateAuthorityConfig) GetCommonName() *string {
	if o == nil {
		return nil
	}
	return o.CommonName
}

type TokenDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *TokenDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type TokenDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *TokenDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type TokenDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *TokenDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type TokenDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *TokenDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type TokenType string

const (
	TokenTypeTokenDataSourceFile         TokenType = "token_DataSource_File"
	TokenTypeTokenDataSourceInline       TokenType = "token_DataSource_Inline"
	TokenTypeTokenDataSourceInlineString TokenType = "token_DataSource_InlineString"
	TokenTypeTokenDataSourceSecret       TokenType = "token_DataSource_Secret"
)

type Token struct {
	TokenDataSourceFile         *TokenDataSourceFile         `queryParam:"inline"`
	TokenDataSourceInline       *TokenDataSourceInline       `queryParam:"inline"`
	TokenDataSourceInlineString *TokenDataSourceInlineString `queryParam:"inline"`
	TokenDataSourceSecret       *TokenDataSourceSecret       `queryParam:"inline"`

	Type TokenType
}

func CreateTokenTokenDataSourceFile(tokenDataSourceFile TokenDataSourceFile) Token {
	typ := TokenTypeTokenDataSourceFile

	return Token{
		TokenDataSourceFile: &tokenDataSourceFile,
		Type:                typ,
	}
}

func CreateTokenTokenDataSourceInline(tokenDataSourceInline TokenDataSourceInline) Token {
	typ := TokenTypeTokenDataSourceInline

	return Token{
		TokenDataSourceInline: &tokenDataSourceInline,
		Type:                  typ,
	}
}

func CreateTokenTokenDataSourceInlineString(tokenDataSourceInlineString TokenDataSourceInlineString) Token {
	typ := TokenTypeTokenDataSourceInlineString

	return Token{
		TokenDataSourceInlineString: &tokenDataSourceInlineString,
		Type:                        typ,
	}
}

func CreateTokenTokenDataSourceSecret(tokenDataSourceSecret TokenDataSourceSecret) Token {
	typ := TokenTypeTokenDataSourceSecret

	return Token{
		TokenDataSourceSecret: &tokenDataSourceSecret,
		Type:                  typ,
	}
}

func (u *Token) UnmarshalJSON(data []byte) error {

	var tokenDataSourceFile TokenDataSourceFile = TokenDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceFile, "", true, true); err == nil {
		u.TokenDataSourceFile = &tokenDataSourceFile
		u.Type = TokenTypeTokenDataSourceFile
		return nil
	}

	var tokenDataSourceInline TokenDataSourceInline = TokenDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceInline, "", true, true); err == nil {
		u.TokenDataSourceInline = &tokenDataSourceInline
		u.Type = TokenTypeTokenDataSourceInline
		return nil
	}

	var tokenDataSourceInlineString TokenDataSourceInlineString = TokenDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceInlineString, "", true, true); err == nil {
		u.TokenDataSourceInlineString = &tokenDataSourceInlineString
		u.Type = TokenTypeTokenDataSourceInlineString
		return nil
	}

	var tokenDataSourceSecret TokenDataSourceSecret = TokenDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &tokenDataSourceSecret, "", true, true); err == nil {
		u.TokenDataSourceSecret = &tokenDataSourceSecret
		u.Type = TokenTypeTokenDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Token", string(data))
}

func (u Token) MarshalJSON() ([]byte, error) {
	if u.TokenDataSourceFile != nil {
		return utils.MarshalJSON(u.TokenDataSourceFile, "", true)
	}

	if u.TokenDataSourceInline != nil {
		return utils.MarshalJSON(u.TokenDataSourceInline, "", true)
	}

	if u.TokenDataSourceInlineString != nil {
		return utils.MarshalJSON(u.TokenDataSourceInlineString, "", true)
	}

	if u.TokenDataSourceSecret != nil {
		return utils.MarshalJSON(u.TokenDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Token: all fields are null")
}

type VaultCertificateAuthorityConfigFromCpAuthToken struct {
	Token *Token `json:"token,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpAuthToken) GetToken() *Token {
	if o == nil {
		return nil
	}
	return o.Token
}

type ClientCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *ClientCertDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type ClientCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *ClientCertDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type ClientCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *ClientCertDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type ClientCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *ClientCertDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type AuthClientCertType string

const (
	AuthClientCertTypeClientCertDataSourceFile         AuthClientCertType = "clientCert_DataSource_File"
	AuthClientCertTypeClientCertDataSourceInline       AuthClientCertType = "clientCert_DataSource_Inline"
	AuthClientCertTypeClientCertDataSourceInlineString AuthClientCertType = "clientCert_DataSource_InlineString"
	AuthClientCertTypeClientCertDataSourceSecret       AuthClientCertType = "clientCert_DataSource_Secret"
)

type AuthClientCert struct {
	ClientCertDataSourceFile         *ClientCertDataSourceFile         `queryParam:"inline"`
	ClientCertDataSourceInline       *ClientCertDataSourceInline       `queryParam:"inline"`
	ClientCertDataSourceInlineString *ClientCertDataSourceInlineString `queryParam:"inline"`
	ClientCertDataSourceSecret       *ClientCertDataSourceSecret       `queryParam:"inline"`

	Type AuthClientCertType
}

func CreateAuthClientCertClientCertDataSourceFile(clientCertDataSourceFile ClientCertDataSourceFile) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceFile

	return AuthClientCert{
		ClientCertDataSourceFile: &clientCertDataSourceFile,
		Type:                     typ,
	}
}

func CreateAuthClientCertClientCertDataSourceInline(clientCertDataSourceInline ClientCertDataSourceInline) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceInline

	return AuthClientCert{
		ClientCertDataSourceInline: &clientCertDataSourceInline,
		Type:                       typ,
	}
}

func CreateAuthClientCertClientCertDataSourceInlineString(clientCertDataSourceInlineString ClientCertDataSourceInlineString) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceInlineString

	return AuthClientCert{
		ClientCertDataSourceInlineString: &clientCertDataSourceInlineString,
		Type:                             typ,
	}
}

func CreateAuthClientCertClientCertDataSourceSecret(clientCertDataSourceSecret ClientCertDataSourceSecret) AuthClientCert {
	typ := AuthClientCertTypeClientCertDataSourceSecret

	return AuthClientCert{
		ClientCertDataSourceSecret: &clientCertDataSourceSecret,
		Type:                       typ,
	}
}

func (u *AuthClientCert) UnmarshalJSON(data []byte) error {

	var clientCertDataSourceFile ClientCertDataSourceFile = ClientCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceFile, "", true, true); err == nil {
		u.ClientCertDataSourceFile = &clientCertDataSourceFile
		u.Type = AuthClientCertTypeClientCertDataSourceFile
		return nil
	}

	var clientCertDataSourceInline ClientCertDataSourceInline = ClientCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceInline, "", true, true); err == nil {
		u.ClientCertDataSourceInline = &clientCertDataSourceInline
		u.Type = AuthClientCertTypeClientCertDataSourceInline
		return nil
	}

	var clientCertDataSourceInlineString ClientCertDataSourceInlineString = ClientCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceInlineString, "", true, true); err == nil {
		u.ClientCertDataSourceInlineString = &clientCertDataSourceInlineString
		u.Type = AuthClientCertTypeClientCertDataSourceInlineString
		return nil
	}

	var clientCertDataSourceSecret ClientCertDataSourceSecret = ClientCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &clientCertDataSourceSecret, "", true, true); err == nil {
		u.ClientCertDataSourceSecret = &clientCertDataSourceSecret
		u.Type = AuthClientCertTypeClientCertDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientCert", string(data))
}

func (u AuthClientCert) MarshalJSON() ([]byte, error) {
	if u.ClientCertDataSourceFile != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceFile, "", true)
	}

	if u.ClientCertDataSourceInline != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceInline, "", true)
	}

	if u.ClientCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceInlineString, "", true)
	}

	if u.ClientCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.ClientCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AuthClientCert: all fields are null")
}

type ClientKeyDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *ClientKeyDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type ClientKeyDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *ClientKeyDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type ClientKeyDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *ClientKeyDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type ClientKeyDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *ClientKeyDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type AuthClientKeyType string

const (
	AuthClientKeyTypeClientKeyDataSourceFile         AuthClientKeyType = "clientKey_DataSource_File"
	AuthClientKeyTypeClientKeyDataSourceInline       AuthClientKeyType = "clientKey_DataSource_Inline"
	AuthClientKeyTypeClientKeyDataSourceInlineString AuthClientKeyType = "clientKey_DataSource_InlineString"
	AuthClientKeyTypeClientKeyDataSourceSecret       AuthClientKeyType = "clientKey_DataSource_Secret"
)

type AuthClientKey struct {
	ClientKeyDataSourceFile         *ClientKeyDataSourceFile         `queryParam:"inline"`
	ClientKeyDataSourceInline       *ClientKeyDataSourceInline       `queryParam:"inline"`
	ClientKeyDataSourceInlineString *ClientKeyDataSourceInlineString `queryParam:"inline"`
	ClientKeyDataSourceSecret       *ClientKeyDataSourceSecret       `queryParam:"inline"`

	Type AuthClientKeyType
}

func CreateAuthClientKeyClientKeyDataSourceFile(clientKeyDataSourceFile ClientKeyDataSourceFile) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceFile

	return AuthClientKey{
		ClientKeyDataSourceFile: &clientKeyDataSourceFile,
		Type:                    typ,
	}
}

func CreateAuthClientKeyClientKeyDataSourceInline(clientKeyDataSourceInline ClientKeyDataSourceInline) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceInline

	return AuthClientKey{
		ClientKeyDataSourceInline: &clientKeyDataSourceInline,
		Type:                      typ,
	}
}

func CreateAuthClientKeyClientKeyDataSourceInlineString(clientKeyDataSourceInlineString ClientKeyDataSourceInlineString) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceInlineString

	return AuthClientKey{
		ClientKeyDataSourceInlineString: &clientKeyDataSourceInlineString,
		Type:                            typ,
	}
}

func CreateAuthClientKeyClientKeyDataSourceSecret(clientKeyDataSourceSecret ClientKeyDataSourceSecret) AuthClientKey {
	typ := AuthClientKeyTypeClientKeyDataSourceSecret

	return AuthClientKey{
		ClientKeyDataSourceSecret: &clientKeyDataSourceSecret,
		Type:                      typ,
	}
}

func (u *AuthClientKey) UnmarshalJSON(data []byte) error {

	var clientKeyDataSourceFile ClientKeyDataSourceFile = ClientKeyDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceFile, "", true, true); err == nil {
		u.ClientKeyDataSourceFile = &clientKeyDataSourceFile
		u.Type = AuthClientKeyTypeClientKeyDataSourceFile
		return nil
	}

	var clientKeyDataSourceInline ClientKeyDataSourceInline = ClientKeyDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceInline, "", true, true); err == nil {
		u.ClientKeyDataSourceInline = &clientKeyDataSourceInline
		u.Type = AuthClientKeyTypeClientKeyDataSourceInline
		return nil
	}

	var clientKeyDataSourceInlineString ClientKeyDataSourceInlineString = ClientKeyDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceInlineString, "", true, true); err == nil {
		u.ClientKeyDataSourceInlineString = &clientKeyDataSourceInlineString
		u.Type = AuthClientKeyTypeClientKeyDataSourceInlineString
		return nil
	}

	var clientKeyDataSourceSecret ClientKeyDataSourceSecret = ClientKeyDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &clientKeyDataSourceSecret, "", true, true); err == nil {
		u.ClientKeyDataSourceSecret = &clientKeyDataSourceSecret
		u.Type = AuthClientKeyTypeClientKeyDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthClientKey", string(data))
}

func (u AuthClientKey) MarshalJSON() ([]byte, error) {
	if u.ClientKeyDataSourceFile != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceFile, "", true)
	}

	if u.ClientKeyDataSourceInline != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceInline, "", true)
	}

	if u.ClientKeyDataSourceInlineString != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceInlineString, "", true)
	}

	if u.ClientKeyDataSourceSecret != nil {
		return utils.MarshalJSON(u.ClientKeyDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type AuthClientKey: all fields are null")
}

type AuthTLS struct {
	ClientCert *AuthClientCert `json:"clientCert,omitempty"`
	ClientKey  *AuthClientKey  `json:"clientKey,omitempty"`
}

func (o *AuthTLS) GetClientCert() *AuthClientCert {
	if o == nil {
		return nil
	}
	return o.ClientCert
}

func (o *AuthTLS) GetClientKey() *AuthClientKey {
	if o == nil {
		return nil
	}
	return o.ClientKey
}

type VaultCertificateAuthorityConfigFromCpAuthTLS struct {
	TLS *AuthTLS `json:"tls,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpAuthTLS) GetTLS() *AuthTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

type AuthTypeType string

const (
	AuthTypeTypeStr     AuthTypeType = "str"
	AuthTypeTypeInteger AuthTypeType = "integer"
)

type AuthType struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type AuthTypeType
}

func CreateAuthTypeStr(str string) AuthType {
	typ := AuthTypeTypeStr

	return AuthType{
		Str:  &str,
		Type: typ,
	}
}

func CreateAuthTypeInteger(integer int64) AuthType {
	typ := AuthTypeTypeInteger

	return AuthType{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *AuthType) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = AuthTypeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = AuthTypeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AuthType", string(data))
}

func (u AuthType) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type AuthType: all fields are null")
}

type Aws struct {
	IamServerIDHeader *string   `json:"iamServerIdHeader,omitempty"`
	Role              *string   `json:"role,omitempty"`
	Type              *AuthType `json:"type,omitempty"`
}

func (o *Aws) GetIamServerIDHeader() *string {
	if o == nil {
		return nil
	}
	return o.IamServerIDHeader
}

func (o *Aws) GetRole() *string {
	if o == nil {
		return nil
	}
	return o.Role
}

func (o *Aws) GetType() *AuthType {
	if o == nil {
		return nil
	}
	return o.Type
}

type VaultCertificateAuthorityConfigFromCpAuthAws struct {
	Aws *Aws `json:"aws,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpAuthAws) GetAws() *Aws {
	if o == nil {
		return nil
	}
	return o.Aws
}

type VaultCertificateAuthorityConfigAuthType string

const (
	VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws   VaultCertificateAuthorityConfigAuthType = "VaultCertificateAuthorityConfig_FromCp_Auth_Aws"
	VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS   VaultCertificateAuthorityConfigAuthType = "VaultCertificateAuthorityConfig_FromCp_Auth_Tls"
	VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken VaultCertificateAuthorityConfigAuthType = "VaultCertificateAuthorityConfig_FromCp_Auth_Token"
)

type VaultCertificateAuthorityConfigAuth struct {
	VaultCertificateAuthorityConfigFromCpAuthAws   *VaultCertificateAuthorityConfigFromCpAuthAws   `queryParam:"inline"`
	VaultCertificateAuthorityConfigFromCpAuthTLS   *VaultCertificateAuthorityConfigFromCpAuthTLS   `queryParam:"inline"`
	VaultCertificateAuthorityConfigFromCpAuthToken *VaultCertificateAuthorityConfigFromCpAuthToken `queryParam:"inline"`

	Type VaultCertificateAuthorityConfigAuthType
}

func CreateVaultCertificateAuthorityConfigAuthVaultCertificateAuthorityConfigFromCpAuthAws(vaultCertificateAuthorityConfigFromCpAuthAws VaultCertificateAuthorityConfigFromCpAuthAws) VaultCertificateAuthorityConfigAuth {
	typ := VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws

	return VaultCertificateAuthorityConfigAuth{
		VaultCertificateAuthorityConfigFromCpAuthAws: &vaultCertificateAuthorityConfigFromCpAuthAws,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigAuthVaultCertificateAuthorityConfigFromCpAuthTLS(vaultCertificateAuthorityConfigFromCpAuthTLS VaultCertificateAuthorityConfigFromCpAuthTLS) VaultCertificateAuthorityConfigAuth {
	typ := VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS

	return VaultCertificateAuthorityConfigAuth{
		VaultCertificateAuthorityConfigFromCpAuthTLS: &vaultCertificateAuthorityConfigFromCpAuthTLS,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigAuthVaultCertificateAuthorityConfigFromCpAuthToken(vaultCertificateAuthorityConfigFromCpAuthToken VaultCertificateAuthorityConfigFromCpAuthToken) VaultCertificateAuthorityConfigAuth {
	typ := VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken

	return VaultCertificateAuthorityConfigAuth{
		VaultCertificateAuthorityConfigFromCpAuthToken: &vaultCertificateAuthorityConfigFromCpAuthToken,
		Type: typ,
	}
}

func (u *VaultCertificateAuthorityConfigAuth) UnmarshalJSON(data []byte) error {

	var vaultCertificateAuthorityConfigFromCpAuthAws VaultCertificateAuthorityConfigFromCpAuthAws = VaultCertificateAuthorityConfigFromCpAuthAws{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpAuthAws, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpAuthAws = &vaultCertificateAuthorityConfigFromCpAuthAws
		u.Type = VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthAws
		return nil
	}

	var vaultCertificateAuthorityConfigFromCpAuthTLS VaultCertificateAuthorityConfigFromCpAuthTLS = VaultCertificateAuthorityConfigFromCpAuthTLS{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpAuthTLS, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpAuthTLS = &vaultCertificateAuthorityConfigFromCpAuthTLS
		u.Type = VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthTLS
		return nil
	}

	var vaultCertificateAuthorityConfigFromCpAuthToken VaultCertificateAuthorityConfigFromCpAuthToken = VaultCertificateAuthorityConfigFromCpAuthToken{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpAuthToken, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpAuthToken = &vaultCertificateAuthorityConfigFromCpAuthToken
		u.Type = VaultCertificateAuthorityConfigAuthTypeVaultCertificateAuthorityConfigFromCpAuthToken
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigAuth", string(data))
}

func (u VaultCertificateAuthorityConfigAuth) MarshalJSON() ([]byte, error) {
	if u.VaultCertificateAuthorityConfigFromCpAuthAws != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpAuthAws, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpAuthTLS != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpAuthTLS, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpAuthToken != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpAuthToken, "", true)
	}

	return nil, errors.New("could not marshal union type VaultCertificateAuthorityConfigAuth: all fields are null")
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type VaultCertificateAuthorityConfigCaCertType string

const (
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile         VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_File"
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline       VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_Inline"
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_InlineString"
	VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret       VaultCertificateAuthorityConfigCaCertType = "VaultCertificateAuthorityConfig_FromCp__caCert_DataSource_Secret"
)

type VaultCertificateAuthorityConfigCaCert struct {
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile         *VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile         `queryParam:"inline"`
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline       *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline       `queryParam:"inline"`
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString *VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString `queryParam:"inline"`
	VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret       *VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret       `queryParam:"inline"`

	Type VaultCertificateAuthorityConfigCaCertType
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile(vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline(vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString(vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString,
		Type: typ,
	}
}

func CreateVaultCertificateAuthorityConfigCaCertVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret(vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret) VaultCertificateAuthorityConfigCaCert {
	typ := VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret

	return VaultCertificateAuthorityConfigCaCert{
		VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret: &vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret,
		Type: typ,
	}
}

func (u *VaultCertificateAuthorityConfigCaCert) UnmarshalJSON(data []byte) error {

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile = VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile = &vaultCertificateAuthorityConfigFromCpCaCertDataSourceFile
		u.Type = VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceFile
		return nil
	}

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline = VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline = &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInline
		u.Type = VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInline
		return nil
	}

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString = VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString = &vaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString
		u.Type = VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString
		return nil
	}

	var vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret = VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret = &vaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret
		u.Type = VaultCertificateAuthorityConfigCaCertTypeVaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfigCaCert", string(data))
}

func (u VaultCertificateAuthorityConfigCaCert) MarshalJSON() ([]byte, error) {
	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceFile, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInline, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceInlineString, "", true)
	}

	if u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCpCaCertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type VaultCertificateAuthorityConfigCaCert: all fields are null")
}

type VaultCertificateAuthorityConfigTLS struct {
	CaCert     *VaultCertificateAuthorityConfigCaCert `json:"caCert,omitempty"`
	ServerName *string                                `json:"serverName,omitempty"`
	SkipVerify *bool                                  `json:"skipVerify,omitempty"`
}

func (o *VaultCertificateAuthorityConfigTLS) GetCaCert() *VaultCertificateAuthorityConfigCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

func (o *VaultCertificateAuthorityConfigTLS) GetServerName() *string {
	if o == nil {
		return nil
	}
	return o.ServerName
}

func (o *VaultCertificateAuthorityConfigTLS) GetSkipVerify() *bool {
	if o == nil {
		return nil
	}
	return o.SkipVerify
}

type FromCp struct {
	Address      *string                              `json:"address,omitempty"`
	AgentAddress *string                              `json:"agentAddress,omitempty"`
	Auth         *VaultCertificateAuthorityConfigAuth `json:"auth,omitempty"`
	CommonName   *string                              `json:"commonName,omitempty"`
	Namespace    *string                              `json:"namespace,omitempty"`
	Pki          *string                              `json:"pki,omitempty"`
	Role         *string                              `json:"role,omitempty"`
	TLS          *VaultCertificateAuthorityConfigTLS  `json:"tls,omitempty"`
}

func (o *FromCp) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *FromCp) GetAgentAddress() *string {
	if o == nil {
		return nil
	}
	return o.AgentAddress
}

func (o *FromCp) GetAuth() *VaultCertificateAuthorityConfigAuth {
	if o == nil {
		return nil
	}
	return o.Auth
}

func (o *FromCp) GetCommonName() *string {
	if o == nil {
		return nil
	}
	return o.CommonName
}

func (o *FromCp) GetNamespace() *string {
	if o == nil {
		return nil
	}
	return o.Namespace
}

func (o *FromCp) GetPki() *string {
	if o == nil {
		return nil
	}
	return o.Pki
}

func (o *FromCp) GetRole() *string {
	if o == nil {
		return nil
	}
	return o.Role
}

func (o *FromCp) GetTLS() *VaultCertificateAuthorityConfigTLS {
	if o == nil {
		return nil
	}
	return o.TLS
}

type VaultCertificateAuthorityConfigFromCp struct {
	FromCp *FromCp `json:"fromCp,omitempty"`
}

func (o *VaultCertificateAuthorityConfigFromCp) GetFromCp() *FromCp {
	if o == nil {
		return nil
	}
	return o.FromCp
}

type VaultCertificateAuthorityConfigType string

const (
	VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp VaultCertificateAuthorityConfigType = "VaultCertificateAuthorityConfig_FromCp_"
)

type VaultCertificateAuthorityConfig struct {
	VaultCertificateAuthorityConfigFromCp *VaultCertificateAuthorityConfigFromCp `queryParam:"inline"`

	Type VaultCertificateAuthorityConfigType
}

func CreateVaultCertificateAuthorityConfigVaultCertificateAuthorityConfigFromCp(vaultCertificateAuthorityConfigFromCp VaultCertificateAuthorityConfigFromCp) VaultCertificateAuthorityConfig {
	typ := VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp

	return VaultCertificateAuthorityConfig{
		VaultCertificateAuthorityConfigFromCp: &vaultCertificateAuthorityConfigFromCp,
		Type:                                  typ,
	}
}

func (u *VaultCertificateAuthorityConfig) UnmarshalJSON(data []byte) error {

	var vaultCertificateAuthorityConfigFromCp VaultCertificateAuthorityConfigFromCp = VaultCertificateAuthorityConfigFromCp{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfigFromCp, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfigFromCp = &vaultCertificateAuthorityConfigFromCp
		u.Type = VaultCertificateAuthorityConfigTypeVaultCertificateAuthorityConfigFromCp
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for VaultCertificateAuthorityConfig", string(data))
}

func (u VaultCertificateAuthorityConfig) MarshalJSON() ([]byte, error) {
	if u.VaultCertificateAuthorityConfigFromCp != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfigFromCp, "", true)
	}

	return nil, errors.New("could not marshal union type VaultCertificateAuthorityConfig: all fields are null")
}

type BuiltinCertificateAuthorityConfigConfCaCert struct {
	Expiration *string `json:"expiration,omitempty"`
	RsaBits    *int64  `json:"rsaBits,omitempty"`
}

func (o *BuiltinCertificateAuthorityConfigConfCaCert) GetExpiration() *string {
	if o == nil {
		return nil
	}
	return o.Expiration
}

func (o *BuiltinCertificateAuthorityConfigConfCaCert) GetRsaBits() *int64 {
	if o == nil {
		return nil
	}
	return o.RsaBits
}

type BuiltinCertificateAuthorityConfig struct {
	CaCert *BuiltinCertificateAuthorityConfigConfCaCert `json:"caCert,omitempty"`
}

func (o *BuiltinCertificateAuthorityConfig) GetCaCert() *BuiltinCertificateAuthorityConfigConfCaCert {
	if o == nil {
		return nil
	}
	return o.CaCert
}

type CertDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *CertDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type CertDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *CertDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type CertDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *CertDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type CertDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *CertDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type CertType string

const (
	CertTypeCertDataSourceFile         CertType = "cert_DataSource_File"
	CertTypeCertDataSourceInline       CertType = "cert_DataSource_Inline"
	CertTypeCertDataSourceInlineString CertType = "cert_DataSource_InlineString"
	CertTypeCertDataSourceSecret       CertType = "cert_DataSource_Secret"
)

type Cert struct {
	CertDataSourceFile         *CertDataSourceFile         `queryParam:"inline"`
	CertDataSourceInline       *CertDataSourceInline       `queryParam:"inline"`
	CertDataSourceInlineString *CertDataSourceInlineString `queryParam:"inline"`
	CertDataSourceSecret       *CertDataSourceSecret       `queryParam:"inline"`

	Type CertType
}

func CreateCertCertDataSourceFile(certDataSourceFile CertDataSourceFile) Cert {
	typ := CertTypeCertDataSourceFile

	return Cert{
		CertDataSourceFile: &certDataSourceFile,
		Type:               typ,
	}
}

func CreateCertCertDataSourceInline(certDataSourceInline CertDataSourceInline) Cert {
	typ := CertTypeCertDataSourceInline

	return Cert{
		CertDataSourceInline: &certDataSourceInline,
		Type:                 typ,
	}
}

func CreateCertCertDataSourceInlineString(certDataSourceInlineString CertDataSourceInlineString) Cert {
	typ := CertTypeCertDataSourceInlineString

	return Cert{
		CertDataSourceInlineString: &certDataSourceInlineString,
		Type:                       typ,
	}
}

func CreateCertCertDataSourceSecret(certDataSourceSecret CertDataSourceSecret) Cert {
	typ := CertTypeCertDataSourceSecret

	return Cert{
		CertDataSourceSecret: &certDataSourceSecret,
		Type:                 typ,
	}
}

func (u *Cert) UnmarshalJSON(data []byte) error {

	var certDataSourceFile CertDataSourceFile = CertDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &certDataSourceFile, "", true, true); err == nil {
		u.CertDataSourceFile = &certDataSourceFile
		u.Type = CertTypeCertDataSourceFile
		return nil
	}

	var certDataSourceInline CertDataSourceInline = CertDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &certDataSourceInline, "", true, true); err == nil {
		u.CertDataSourceInline = &certDataSourceInline
		u.Type = CertTypeCertDataSourceInline
		return nil
	}

	var certDataSourceInlineString CertDataSourceInlineString = CertDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &certDataSourceInlineString, "", true, true); err == nil {
		u.CertDataSourceInlineString = &certDataSourceInlineString
		u.Type = CertTypeCertDataSourceInlineString
		return nil
	}

	var certDataSourceSecret CertDataSourceSecret = CertDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &certDataSourceSecret, "", true, true); err == nil {
		u.CertDataSourceSecret = &certDataSourceSecret
		u.Type = CertTypeCertDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Cert", string(data))
}

func (u Cert) MarshalJSON() ([]byte, error) {
	if u.CertDataSourceFile != nil {
		return utils.MarshalJSON(u.CertDataSourceFile, "", true)
	}

	if u.CertDataSourceInline != nil {
		return utils.MarshalJSON(u.CertDataSourceInline, "", true)
	}

	if u.CertDataSourceInlineString != nil {
		return utils.MarshalJSON(u.CertDataSourceInlineString, "", true)
	}

	if u.CertDataSourceSecret != nil {
		return utils.MarshalJSON(u.CertDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Cert: all fields are null")
}

type KeyDataSourceSecret struct {
	// Data source is a secret with given Secret key.
	Secret *string `json:"secret,omitempty"`
}

func (o *KeyDataSourceSecret) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type KeyDataSourceInlineString struct {
	// Data source is inline string
	InlineString *string `json:"inlineString,omitempty"`
}

func (o *KeyDataSourceInlineString) GetInlineString() *string {
	if o == nil {
		return nil
	}
	return o.InlineString
}

type KeyDataSourceInline struct {
	// Data source is inline bytes.
	Inline *string `json:"inline,omitempty"`
}

func (o *KeyDataSourceInline) GetInline() *string {
	if o == nil {
		return nil
	}
	return o.Inline
}

type KeyDataSourceFile struct {
	// Data source is a path to a file.
	// Deprecated, use other sources of a data.
	File *string `json:"file,omitempty"`
}

func (o *KeyDataSourceFile) GetFile() *string {
	if o == nil {
		return nil
	}
	return o.File
}

type KeyType string

const (
	KeyTypeKeyDataSourceFile         KeyType = "key_DataSource_File"
	KeyTypeKeyDataSourceInline       KeyType = "key_DataSource_Inline"
	KeyTypeKeyDataSourceInlineString KeyType = "key_DataSource_InlineString"
	KeyTypeKeyDataSourceSecret       KeyType = "key_DataSource_Secret"
)

type Key struct {
	KeyDataSourceFile         *KeyDataSourceFile         `queryParam:"inline"`
	KeyDataSourceInline       *KeyDataSourceInline       `queryParam:"inline"`
	KeyDataSourceInlineString *KeyDataSourceInlineString `queryParam:"inline"`
	KeyDataSourceSecret       *KeyDataSourceSecret       `queryParam:"inline"`

	Type KeyType
}

func CreateKeyKeyDataSourceFile(keyDataSourceFile KeyDataSourceFile) Key {
	typ := KeyTypeKeyDataSourceFile

	return Key{
		KeyDataSourceFile: &keyDataSourceFile,
		Type:              typ,
	}
}

func CreateKeyKeyDataSourceInline(keyDataSourceInline KeyDataSourceInline) Key {
	typ := KeyTypeKeyDataSourceInline

	return Key{
		KeyDataSourceInline: &keyDataSourceInline,
		Type:                typ,
	}
}

func CreateKeyKeyDataSourceInlineString(keyDataSourceInlineString KeyDataSourceInlineString) Key {
	typ := KeyTypeKeyDataSourceInlineString

	return Key{
		KeyDataSourceInlineString: &keyDataSourceInlineString,
		Type:                      typ,
	}
}

func CreateKeyKeyDataSourceSecret(keyDataSourceSecret KeyDataSourceSecret) Key {
	typ := KeyTypeKeyDataSourceSecret

	return Key{
		KeyDataSourceSecret: &keyDataSourceSecret,
		Type:                typ,
	}
}

func (u *Key) UnmarshalJSON(data []byte) error {

	var keyDataSourceFile KeyDataSourceFile = KeyDataSourceFile{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceFile, "", true, true); err == nil {
		u.KeyDataSourceFile = &keyDataSourceFile
		u.Type = KeyTypeKeyDataSourceFile
		return nil
	}

	var keyDataSourceInline KeyDataSourceInline = KeyDataSourceInline{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceInline, "", true, true); err == nil {
		u.KeyDataSourceInline = &keyDataSourceInline
		u.Type = KeyTypeKeyDataSourceInline
		return nil
	}

	var keyDataSourceInlineString KeyDataSourceInlineString = KeyDataSourceInlineString{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceInlineString, "", true, true); err == nil {
		u.KeyDataSourceInlineString = &keyDataSourceInlineString
		u.Type = KeyTypeKeyDataSourceInlineString
		return nil
	}

	var keyDataSourceSecret KeyDataSourceSecret = KeyDataSourceSecret{}
	if err := utils.UnmarshalJSON(data, &keyDataSourceSecret, "", true, true); err == nil {
		u.KeyDataSourceSecret = &keyDataSourceSecret
		u.Type = KeyTypeKeyDataSourceSecret
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Key", string(data))
}

func (u Key) MarshalJSON() ([]byte, error) {
	if u.KeyDataSourceFile != nil {
		return utils.MarshalJSON(u.KeyDataSourceFile, "", true)
	}

	if u.KeyDataSourceInline != nil {
		return utils.MarshalJSON(u.KeyDataSourceInline, "", true)
	}

	if u.KeyDataSourceInlineString != nil {
		return utils.MarshalJSON(u.KeyDataSourceInlineString, "", true)
	}

	if u.KeyDataSourceSecret != nil {
		return utils.MarshalJSON(u.KeyDataSourceSecret, "", true)
	}

	return nil, errors.New("could not marshal union type Key: all fields are null")
}

type ProvidedCertificateAuthorityConfig struct {
	Cert *Cert `json:"cert,omitempty"`
	Key  *Key  `json:"key,omitempty"`
}

func (o *ProvidedCertificateAuthorityConfig) GetCert() *Cert {
	if o == nil {
		return nil
	}
	return o.Cert
}

func (o *ProvidedCertificateAuthorityConfig) GetKey() *Key {
	if o == nil {
		return nil
	}
	return o.Key
}

type MeshItemMtlsConfType string

const (
	MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig    MeshItemMtlsConfType = "ProvidedCertificateAuthorityConfig"
	MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig     MeshItemMtlsConfType = "BuiltinCertificateAuthorityConfig"
	MeshItemMtlsConfTypeVaultCertificateAuthorityConfig       MeshItemMtlsConfType = "VaultCertificateAuthorityConfig"
	MeshItemMtlsConfTypeACMCertificateAuthorityConfig         MeshItemMtlsConfType = "ACMCertificateAuthorityConfig"
	MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig MeshItemMtlsConfType = "CertManagerCertificateAuthorityConfig"
)

type MeshItemMtlsConf struct {
	ProvidedCertificateAuthorityConfig    *ProvidedCertificateAuthorityConfig    `queryParam:"inline"`
	BuiltinCertificateAuthorityConfig     *BuiltinCertificateAuthorityConfig     `queryParam:"inline"`
	VaultCertificateAuthorityConfig       *VaultCertificateAuthorityConfig       `queryParam:"inline"`
	ACMCertificateAuthorityConfig         *ACMCertificateAuthorityConfig         `queryParam:"inline"`
	CertManagerCertificateAuthorityConfig *CertManagerCertificateAuthorityConfig `queryParam:"inline"`

	Type MeshItemMtlsConfType
}

func CreateMeshItemMtlsConfProvidedCertificateAuthorityConfig(providedCertificateAuthorityConfig ProvidedCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig

	return MeshItemMtlsConf{
		ProvidedCertificateAuthorityConfig: &providedCertificateAuthorityConfig,
		Type:                               typ,
	}
}

func CreateMeshItemMtlsConfBuiltinCertificateAuthorityConfig(builtinCertificateAuthorityConfig BuiltinCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig

	return MeshItemMtlsConf{
		BuiltinCertificateAuthorityConfig: &builtinCertificateAuthorityConfig,
		Type:                              typ,
	}
}

func CreateMeshItemMtlsConfVaultCertificateAuthorityConfig(vaultCertificateAuthorityConfig VaultCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeVaultCertificateAuthorityConfig

	return MeshItemMtlsConf{
		VaultCertificateAuthorityConfig: &vaultCertificateAuthorityConfig,
		Type:                            typ,
	}
}

func CreateMeshItemMtlsConfACMCertificateAuthorityConfig(acmCertificateAuthorityConfig ACMCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeACMCertificateAuthorityConfig

	return MeshItemMtlsConf{
		ACMCertificateAuthorityConfig: &acmCertificateAuthorityConfig,
		Type:                          typ,
	}
}

func CreateMeshItemMtlsConfCertManagerCertificateAuthorityConfig(certManagerCertificateAuthorityConfig CertManagerCertificateAuthorityConfig) MeshItemMtlsConf {
	typ := MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig

	return MeshItemMtlsConf{
		CertManagerCertificateAuthorityConfig: &certManagerCertificateAuthorityConfig,
		Type:                                  typ,
	}
}

func (u *MeshItemMtlsConf) UnmarshalJSON(data []byte) error {

	var builtinCertificateAuthorityConfig BuiltinCertificateAuthorityConfig = BuiltinCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &builtinCertificateAuthorityConfig, "", true, true); err == nil {
		u.BuiltinCertificateAuthorityConfig = &builtinCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeBuiltinCertificateAuthorityConfig
		return nil
	}

	var providedCertificateAuthorityConfig ProvidedCertificateAuthorityConfig = ProvidedCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &providedCertificateAuthorityConfig, "", true, true); err == nil {
		u.ProvidedCertificateAuthorityConfig = &providedCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeProvidedCertificateAuthorityConfig
		return nil
	}

	var acmCertificateAuthorityConfig ACMCertificateAuthorityConfig = ACMCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &acmCertificateAuthorityConfig, "", true, true); err == nil {
		u.ACMCertificateAuthorityConfig = &acmCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeACMCertificateAuthorityConfig
		return nil
	}

	var certManagerCertificateAuthorityConfig CertManagerCertificateAuthorityConfig = CertManagerCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &certManagerCertificateAuthorityConfig, "", true, true); err == nil {
		u.CertManagerCertificateAuthorityConfig = &certManagerCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeCertManagerCertificateAuthorityConfig
		return nil
	}

	var vaultCertificateAuthorityConfig VaultCertificateAuthorityConfig = VaultCertificateAuthorityConfig{}
	if err := utils.UnmarshalJSON(data, &vaultCertificateAuthorityConfig, "", true, true); err == nil {
		u.VaultCertificateAuthorityConfig = &vaultCertificateAuthorityConfig
		u.Type = MeshItemMtlsConfTypeVaultCertificateAuthorityConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMtlsConf", string(data))
}

func (u MeshItemMtlsConf) MarshalJSON() ([]byte, error) {
	if u.ProvidedCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.ProvidedCertificateAuthorityConfig, "", true)
	}

	if u.BuiltinCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.BuiltinCertificateAuthorityConfig, "", true)
	}

	if u.VaultCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.VaultCertificateAuthorityConfig, "", true)
	}

	if u.ACMCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.ACMCertificateAuthorityConfig, "", true)
	}

	if u.CertManagerCertificateAuthorityConfig != nil {
		return utils.MarshalJSON(u.CertManagerCertificateAuthorityConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMtlsConf: all fields are null")
}

// RequestTimeout - Timeout on request to CA for DP certificate generation and retrieval
type RequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *RequestTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *RequestTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

// Rotation settings
type Rotation struct {
	// Time after which generated certificate for Dataplane will expire
	Expiration *string `json:"expiration,omitempty"`
}

func (o *Rotation) GetExpiration() *string {
	if o == nil {
		return nil
	}
	return o.Expiration
}

// DpCert - Dataplane certificate settings
type DpCert struct {
	// Timeout on request to CA for DP certificate generation and retrieval
	RequestTimeout *RequestTimeout `json:"requestTimeout,omitempty"`
	// Rotation settings
	Rotation *Rotation `json:"rotation,omitempty"`
}

func (o *DpCert) GetRequestTimeout() *RequestTimeout {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *DpCert) GetRotation() *Rotation {
	if o == nil {
		return nil
	}
	return o.Rotation
}

type MeshItemMtlsModeType string

const (
	MeshItemMtlsModeTypeStr     MeshItemMtlsModeType = "str"
	MeshItemMtlsModeTypeInteger MeshItemMtlsModeType = "integer"
)

// MeshItemMtlsMode - Mode defines the behaviour of inbound listeners with regard to traffic
// encryption
type MeshItemMtlsMode struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`

	Type MeshItemMtlsModeType
}

func CreateMeshItemMtlsModeStr(str string) MeshItemMtlsMode {
	typ := MeshItemMtlsModeTypeStr

	return MeshItemMtlsMode{
		Str:  &str,
		Type: typ,
	}
}

func CreateMeshItemMtlsModeInteger(integer int64) MeshItemMtlsMode {
	typ := MeshItemMtlsModeTypeInteger

	return MeshItemMtlsMode{
		Integer: &integer,
		Type:    typ,
	}
}

func (u *MeshItemMtlsMode) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MeshItemMtlsModeTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = MeshItemMtlsModeTypeInteger
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemMtlsMode", string(data))
}

func (u MeshItemMtlsMode) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemMtlsMode: all fields are null")
}

// MeshItemRequestTimeout - Timeout on request for to CA for root certificate chain.
// If not specified, defaults to 10s.
type MeshItemRequestTimeout struct {
	Nanos   *int64 `json:"nanos,omitempty"`
	Seconds *int64 `json:"seconds,omitempty"`
}

func (o *MeshItemRequestTimeout) GetNanos() *int64 {
	if o == nil {
		return nil
	}
	return o.Nanos
}

func (o *MeshItemRequestTimeout) GetSeconds() *int64 {
	if o == nil {
		return nil
	}
	return o.Seconds
}

type RootChain struct {
	// Timeout on request for to CA for root certificate chain.
	// If not specified, defaults to 10s.
	RequestTimeout *MeshItemRequestTimeout `json:"requestTimeout,omitempty"`
}

func (o *RootChain) GetRequestTimeout() *MeshItemRequestTimeout {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

// MeshItemMtlsBackends - CertificateAuthorityBackend defines Certificate Authority backend
type MeshItemMtlsBackends struct {
	Conf *MeshItemMtlsConf `json:"conf,omitempty"`
	// Dataplane certificate settings
	DpCert *DpCert `json:"dpCert,omitempty"`
	// Mode defines the behaviour of inbound listeners with regard to traffic
	// encryption
	Mode *MeshItemMtlsMode `json:"mode,omitempty"`
	// Name of the backend
	Name      *string    `json:"name,omitempty"`
	RootChain *RootChain `json:"rootChain,omitempty"`
	// Type of the backend. Has to be one of the loaded plugins (Kuma ships with
	// builtin and provided)
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemMtlsBackends) GetConf() *MeshItemMtlsConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemMtlsBackends) GetDpCert() *DpCert {
	if o == nil {
		return nil
	}
	return o.DpCert
}

func (o *MeshItemMtlsBackends) GetMode() *MeshItemMtlsMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *MeshItemMtlsBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemMtlsBackends) GetRootChain() *RootChain {
	if o == nil {
		return nil
	}
	return o.RootChain
}

func (o *MeshItemMtlsBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Mtls - mTLS settings.
// +optional
type Mtls struct {
	// List of available Certificate Authority backends
	Backends []MeshItemMtlsBackends `json:"backends,omitempty"`
	// Name of the enabled backend
	EnabledBackend *string `json:"enabledBackend,omitempty"`
	// If enabled, skips CA validation.
	SkipValidation *bool `json:"skipValidation,omitempty"`
}

func (o *Mtls) GetBackends() []MeshItemMtlsBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Mtls) GetEnabledBackend() *string {
	if o == nil {
		return nil
	}
	return o.EnabledBackend
}

func (o *Mtls) GetSkipValidation() *bool {
	if o == nil {
		return nil
	}
	return o.SkipValidation
}

// Outbound settings
type Outbound struct {
	// Control the passthrough cluster
	Passthrough *bool `json:"passthrough,omitempty"`
}

func (o *Outbound) GetPassthrough() *bool {
	if o == nil {
		return nil
	}
	return o.Passthrough
}

// Networking settings of the mesh
type Networking struct {
	// Outbound settings
	Outbound *Outbound `json:"outbound,omitempty"`
}

func (o *Networking) GetOutbound() *Outbound {
	if o == nil {
		return nil
	}
	return o.Outbound
}

// Routing settings of the mesh
type Routing struct {
	// If true, blocks traffic to MeshExternalServices.
	// Default: false
	DefaultForbidMeshExternalServiceAccess *bool `json:"defaultForbidMeshExternalServiceAccess,omitempty"`
	// Enable the Locality Aware Load Balancing
	LocalityAwareLoadBalancing *bool `json:"localityAwareLoadBalancing,omitempty"`
	// Enable routing traffic to services in other zone or external services
	// through ZoneEgress. Default: false
	ZoneEgress *bool `json:"zoneEgress,omitempty"`
}

func (o *Routing) GetDefaultForbidMeshExternalServiceAccess() *bool {
	if o == nil {
		return nil
	}
	return o.DefaultForbidMeshExternalServiceAccess
}

func (o *Routing) GetLocalityAwareLoadBalancing() *bool {
	if o == nil {
		return nil
	}
	return o.LocalityAwareLoadBalancing
}

func (o *Routing) GetZoneEgress() *bool {
	if o == nil {
		return nil
	}
	return o.ZoneEgress
}

type ZipkinTracingBackendConfig struct {
	// Version of the API. values: httpJson, httpJsonV1, httpProto. Default:
	// httpJson see
	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/trace.proto#envoy-v3-api-enum-config-trace-v3-zipkinconfig-collectorendpointversion
	APIVersion *string `json:"apiVersion,omitempty"`
	// Determines whether client and server spans will share the same span
	// context. Default: true.
	// https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/trace/v3/zipkin.proto#config-trace-v3-zipkinconfig
	SharedSpanContext *bool `json:"sharedSpanContext,omitempty"`
	// Generate 128bit traces. Default: false
	TraceId128bit *bool `json:"traceId128bit,omitempty"`
	// Address of Zipkin collector.
	URL *string `json:"url,omitempty"`
}

func (o *ZipkinTracingBackendConfig) GetAPIVersion() *string {
	if o == nil {
		return nil
	}
	return o.APIVersion
}

func (o *ZipkinTracingBackendConfig) GetSharedSpanContext() *bool {
	if o == nil {
		return nil
	}
	return o.SharedSpanContext
}

func (o *ZipkinTracingBackendConfig) GetTraceId128bit() *bool {
	if o == nil {
		return nil
	}
	return o.TraceId128bit
}

func (o *ZipkinTracingBackendConfig) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

type DatadogTracingBackendConfig struct {
	// Address of datadog collector.
	Address *string `json:"address,omitempty"`
	// Port of datadog collector
	Port *int64 `json:"port,omitempty"`
	// Determines if datadog service name should be split based on traffic
	// direction and destination. For example, with `splitService: true` and a
	// `backend` service that communicates with a couple of databases, you would
	// get service names like `backend_INBOUND`, `backend_OUTBOUND_db1`, and
	// `backend_OUTBOUND_db2` in Datadog. Default: false
	SplitService *bool `json:"splitService,omitempty"`
}

func (o *DatadogTracingBackendConfig) GetAddress() *string {
	if o == nil {
		return nil
	}
	return o.Address
}

func (o *DatadogTracingBackendConfig) GetPort() *int64 {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *DatadogTracingBackendConfig) GetSplitService() *bool {
	if o == nil {
		return nil
	}
	return o.SplitService
}

type MeshItemTracingConfType string

const (
	MeshItemTracingConfTypeDatadogTracingBackendConfig MeshItemTracingConfType = "DatadogTracingBackendConfig"
	MeshItemTracingConfTypeZipkinTracingBackendConfig  MeshItemTracingConfType = "ZipkinTracingBackendConfig"
)

type MeshItemTracingConf struct {
	DatadogTracingBackendConfig *DatadogTracingBackendConfig `queryParam:"inline"`
	ZipkinTracingBackendConfig  *ZipkinTracingBackendConfig  `queryParam:"inline"`

	Type MeshItemTracingConfType
}

func CreateMeshItemTracingConfDatadogTracingBackendConfig(datadogTracingBackendConfig DatadogTracingBackendConfig) MeshItemTracingConf {
	typ := MeshItemTracingConfTypeDatadogTracingBackendConfig

	return MeshItemTracingConf{
		DatadogTracingBackendConfig: &datadogTracingBackendConfig,
		Type:                        typ,
	}
}

func CreateMeshItemTracingConfZipkinTracingBackendConfig(zipkinTracingBackendConfig ZipkinTracingBackendConfig) MeshItemTracingConf {
	typ := MeshItemTracingConfTypeZipkinTracingBackendConfig

	return MeshItemTracingConf{
		ZipkinTracingBackendConfig: &zipkinTracingBackendConfig,
		Type:                       typ,
	}
}

func (u *MeshItemTracingConf) UnmarshalJSON(data []byte) error {

	var datadogTracingBackendConfig DatadogTracingBackendConfig = DatadogTracingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &datadogTracingBackendConfig, "", true, true); err == nil {
		u.DatadogTracingBackendConfig = &datadogTracingBackendConfig
		u.Type = MeshItemTracingConfTypeDatadogTracingBackendConfig
		return nil
	}

	var zipkinTracingBackendConfig ZipkinTracingBackendConfig = ZipkinTracingBackendConfig{}
	if err := utils.UnmarshalJSON(data, &zipkinTracingBackendConfig, "", true, true); err == nil {
		u.ZipkinTracingBackendConfig = &zipkinTracingBackendConfig
		u.Type = MeshItemTracingConfTypeZipkinTracingBackendConfig
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MeshItemTracingConf", string(data))
}

func (u MeshItemTracingConf) MarshalJSON() ([]byte, error) {
	if u.DatadogTracingBackendConfig != nil {
		return utils.MarshalJSON(u.DatadogTracingBackendConfig, "", true)
	}

	if u.ZipkinTracingBackendConfig != nil {
		return utils.MarshalJSON(u.ZipkinTracingBackendConfig, "", true)
	}

	return nil, errors.New("could not marshal union type MeshItemTracingConf: all fields are null")
}

// MeshItemTracingBackends - TracingBackend defines tracing backend available to mesh.
type MeshItemTracingBackends struct {
	Conf *MeshItemTracingConf `json:"conf,omitempty"`
	// Name of the backend, can be then used in Mesh.tracing.defaultBackend or in
	// TrafficTrace
	Name *string `json:"name,omitempty"`
	// Percentage of traces that will be sent to the backend (range 0.0 - 100.0).
	// Empty value defaults to 100.0%
	Sampling *float64 `json:"sampling,omitempty"`
	// Type of the backend (Kuma ships with 'zipkin')
	Type *string `json:"type,omitempty"`
}

func (o *MeshItemTracingBackends) GetConf() *MeshItemTracingConf {
	if o == nil {
		return nil
	}
	return o.Conf
}

func (o *MeshItemTracingBackends) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *MeshItemTracingBackends) GetSampling() *float64 {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *MeshItemTracingBackends) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

// Tracing settings.
// +optional
type Tracing struct {
	// List of available tracing backends
	Backends []MeshItemTracingBackends `json:"backends,omitempty"`
	// Name of the default backend
	DefaultBackend *string `json:"defaultBackend,omitempty"`
}

func (o *Tracing) GetBackends() []MeshItemTracingBackends {
	if o == nil {
		return nil
	}
	return o.Backends
}

func (o *Tracing) GetDefaultBackend() *string {
	if o == nil {
		return nil
	}
	return o.DefaultBackend
}

// MeshItem - Successful response
type MeshItem struct {
	// Constraints that applies to the mesh and its entities
	Constraints *Constraints      `json:"constraints,omitempty"`
	Labels      map[string]string `json:"labels,omitempty"`
	// Logging settings.
	// +optional
	Logging      *Logging      `json:"logging,omitempty"`
	MeshServices *MeshServices `json:"meshServices,omitempty"`
	// Configuration for metrics collected and exposed by dataplanes.
	//
	// Settings defined here become defaults for every dataplane in a given Mesh.
	// Additionally, it is also possible to further customize this configuration
	// for each dataplane individually using Dataplane resource.
	// +optional
	Metrics *Metrics `json:"metrics,omitempty"`
	// mTLS settings.
	// +optional
	Mtls *Mtls  `json:"mtls,omitempty"`
	Name string `json:"name"`
	// Networking settings of the mesh
	Networking *Networking `json:"networking,omitempty"`
	// Routing settings of the mesh
	Routing *Routing `json:"routing,omitempty"`
	// List of policies to skip creating by default when the mesh is created.
	// e.g. TrafficPermission, MeshRetry, etc. An '*' can be used to skip all
	// policies.
	SkipCreatingInitialPolicies []string `json:"skipCreatingInitialPolicies,omitempty"`
	// Tracing settings.
	// +optional
	Tracing *Tracing `json:"tracing,omitempty"`
	Type    string   `json:"type"`
}

func (o *MeshItem) GetConstraints() *Constraints {
	if o == nil {
		return nil
	}
	return o.Constraints
}

func (o *MeshItem) GetLabels() map[string]string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *MeshItem) GetLogging() *Logging {
	if o == nil {
		return nil
	}
	return o.Logging
}

func (o *MeshItem) GetMeshServices() *MeshServices {
	if o == nil {
		return nil
	}
	return o.MeshServices
}

func (o *MeshItem) GetMetrics() *Metrics {
	if o == nil {
		return nil
	}
	return o.Metrics
}

func (o *MeshItem) GetMtls() *Mtls {
	if o == nil {
		return nil
	}
	return o.Mtls
}

func (o *MeshItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *MeshItem) GetNetworking() *Networking {
	if o == nil {
		return nil
	}
	return o.Networking
}

func (o *MeshItem) GetRouting() *Routing {
	if o == nil {
		return nil
	}
	return o.Routing
}

func (o *MeshItem) GetSkipCreatingInitialPolicies() []string {
	if o == nil {
		return nil
	}
	return o.SkipCreatingInitialPolicies
}

func (o *MeshItem) GetTracing() *Tracing {
	if o == nil {
		return nil
	}
	return o.Tracing
}

func (o *MeshItem) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}
